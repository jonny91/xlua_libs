/*
** This file has been pre-processed with DynASM.
** http://luajit.org/dynasm.html
** DynASM version 1.4.0, DynASM arm version 1.4.0
** DO NOT EDIT! The original file is in "vm_arm64.dasc".
*/

#line 1 "vm_arm64.dasc"
//|// Low-level VM code for ARM64 CPUs.
//|// Bytecode interpreter, fast functions and helper functions.
//|// Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h
//|
//|.arch arm64
#if DASM_VERSION != 10400
#error "Version mismatch between DynASM and included encoding engine"
#endif
#line 6 "vm_arm64.dasc"
//|.section code_op, code_sub
#define DASM_SECTION_CODE_OP	0
#define DASM_SECTION_CODE_SUB	1
#define DASM_MAXSECTION		2
#line 7 "vm_arm64.dasc"
//|
//|.actionlist build_actionlist
static const unsigned int build_actionlist[5418] = {
0x00010001,
0x00060014,
0x36100015,
0x00051015,
0xf85f8235,
0x92e00028,
0xaa1103f3,
0xf81f8f68,
0x00060016,
0xb100239c,
0x52800000,
0x00090205,
0x54000000,
0x00050817,
0xb900c3fc,
0xf20002a0,
0x000d0000,
0x54000000,
0x00050818,
0x00060019,
0x920002b1,
0x000d0000,
0xf100001f,
0x000b0000,
0xcb110271,
0x54000001,
0x00050814,
0xf80002f1,
0x000e0000,
0xb980cbe1,
0x12800008,
0x00090205,
0xd1004273,
0xf100238a,
0xb80002c8,
0x000e0000,
0x54000000,
0x00050802,
0x0006000b,
0xf100214a,
0xf8408768,
0xf8008668,
0x54000001,
0x0005080b,
0x0006000c,
0xeb010f9f,
0x54000001,
0x00050806,
0x0006000d,
0xf80002f3,
0x000e0000,
0x0006001a,
0x00000000,
0xf94053fc,
0x52800000,
0xf80002fc,
0x000e0000,
0x0006001b,
0xa94153f3,
0x6d4627e8,
0xa9425bf5,
0x6d472fea,
0xa94363f7,
0x6d4837ec,
0xa9446bf9,
0x6d493fee,
0xa94573fb,
0xa8cd7bfd,
0xd65f03c0,
0x00060010,
0x5400000c,
0x00050807,
0xf84002e2,
0x000e0000,
0xeb02027f,
0x54000002,
0x00050808,
0xf800867a,
0x9100239c,
0x14000000,
0x0005000c,
0x00060011,
0xb4000001,
0x0005080d,
0xcb010f80,
0xcb000273,
0x14000000,
0x0005000d,
0x00060012,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0x94000000,
0x00030000,
0xf84002f3,
0x000e0000,
0xb980cbe1,
0x14000000,
0x0005000c,
0x0006001c,
0x9100001f,
0xaa0103e0,
0x00060017,
0xf9405bf7,
0x12800008,
0x00090205,
0xf84002f6,
0x000e0000,
0xb80002c8,
0x000e0000,
0x14000000,
0x0005001b,
0x0006001d,
0x00000000,
0x9200001f,
0x000d0000,
0x0006001e,
0xf9405bf7,
0xd2e00018,
0x00090205,
0xd2a00019,
0x00090205,
0x9280001a,
0x5280021c,
0xf84002f3,
0x000e0000,
0xf84002f6,
0x000e0000,
0x92d00008,
0xd100227b,
0xf85f8275,
0xf81f8268,
0xb80002da,
0x000e0000,
0x14000000,
0x00050016,
0x0006001f,
0x52800001,
0x00090205,
0x14000000,
0x00050002,
0x00060020,
0x8b1c027c,
0xcb13037b,
0xaa1703e0,
0xa90072f3,
0x00098cef,
0x910012b5,
0xd343ff61,
0x0006000c,
0xf90057f5,
0x94000000,
0x00030000,
0xa94072f3,
0x00098cef,
0xf85f0262,
0xcb13039c,
0x92000042,
0x000d0000,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00060021,
0xa9b37bfd,
0x910003fd,
0xa90153f3,
0x6d0627e8,
0xa9025bf5,
0x6d072fea,
0xa90363f7,
0x6d0837ec,
0xa9046bf9,
0x6d093fee,
0xa90573fb,
0xaa0003f7,
0xf84002f6,
0x000e0000,
0xaa0103f3,
0xf9005bf7,
0x52800015,
0x00090205,
0x00000000,
0xb900cbff,
0x910003e8,
0x000b0000,
0x384002e9,
0x000e0000,
0xb900c7ff,
0xf90057f7,
0xf90053ff,
0xf80002e8,
0x000e0000,
0x34000009,
0x00050803,
0xf80002d7,
0x000e0000,
0xaa1303fb,
0xa94002f3,
0x00098cef,
0xd2e00018,
0x00090205,
0xd2a00019,
0x00090205,
0xf85f8275,
0x380002ff,
0x000e0000,
0x9280001a,
0xcb13001c,
0xf20002a0,
0x000d0000,
0x9100239c,
0xb80002da,
0x000e0000,
0xb900c3fc,
0x54000000,
0x00050818,
0x14000000,
0x00050019,
0x00060022,
0xa9b37bfd,
0x910003fd,
0xa90153f3,
0x6d0627e8,
0xa9025bf5,
0x6d072fea,
0xa90363f7,
0x6d0837ec,
0xa9046bf9,
0x6d093fee,
0xa90573fb,
0x52800015,
0x00090205,
0xb900c7e3,
0x14000000,
0x00050001,
0x00060023,
0xa9b37bfd,
0x910003fd,
0xa90153f3,
0x6d0627e8,
0xa9025bf5,
0x6d072fea,
0xa90363f7,
0x6d0837ec,
0xa9046bf9,
0x6d093fee,
0xa90573fb,
0x52800015,
0x00090205,
0x0006000b,
0xf840001c,
0x000e0000,
0xb900cbe2,
0xaa0003f7,
0xf9005be0,
0xf84002f6,
0x000e0000,
0xaa0103f3,
0xf90057e0,
0xf90053fc,
0xf80002fd,
0x000e0000,
0x0006000d,
0x00000000,
0xf80002d7,
0x000e0000,
0xa94002f1,
0x00098cef,
0xd2e00018,
0x00090205,
0xd2a00019,
0x00090205,
0x8b1302b5,
0x9280001a,
0xcb1102b5,
0xcb13001c,
0xb80002da,
0x000e0000,
0x00060024,
0xf85f0262,
0x936ffc4f,
0xb10001ff,
0x000b0000,
0x92000042,
0x000d0000,
0x54000001,
0x00050825,
0x00060026,
0xf81f8275,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00060027,
0xa9b37bfd,
0x910003fd,
0xa90153f3,
0x6d0627e8,
0xa9025bf5,
0x6d072fea,
0xa90363f7,
0x6d0837ec,
0xa9046bf9,
0x6d093fee,
0xa90573fb,
0xaa0003f7,
0xf840001b,
0x000e0000,
0xf9005be0,
0xf84002f6,
0x000e0000,
0xf84002f1,
0x000e0000,
0xf90057e0,
0xf84002fc,
0x000e0000,
0xcb11037b,
0xb900cbfb,
0xb900c7ff,
0xf90053fc,
0xf80002fd,
0x000e0000,
0xf80002d7,
0x000e0000,
0xd63f0060,
0xaa0003f3,
0x52800015,
0x00090205,
0xb5000013,
0x0005080d,
0x14000000,
0x0005001a,
0x00060015,
0x00000000,
0xf85f0222,
0xf85e0260,
0xaa1303e3,
0xaa1103f3,
0x92000042,
0x000d0000,
0xf100041f,
0xf85e8075,
0xf8400042,
0x000e0000,
0x8b1c0368,
0xf81f811a,
0x54000009,
0x00050801,
0xf8400054,
0x000e0000,
0xd61f0000,
0x0006000b,
0x54000000,
0x00050828,
0xd1008063,
0xcb13007c,
0x14000000,
0x00050029,
0x0006002a,
0xb85fc2b0,
0xd1008061,
0xf9400368,
0xf80002f3,
0x000e0000,
0xd3587e11,
0xd3483e1b,
0x8b110e69,
0xeb090029,
0x54000000,
0x00050801,
0xf9000028,
0xd343fd22,
0x14000000,
0x0005002b,
0x0006000b,
0xf83b7a68,
0x14000000,
0x0005002c,
0x0006002d,
0x92800003,
0x00090205,
0x8b110e61,
0x8b03bf83,
0x14000000,
0x00050002,
0x0006002e,
0xf2e00001,
0x00090205,
0xf80002c1,
0x000e0000,
0x910002c1,
0x000b0000,
0x0006000c,
0x9102e3e2,
0xf9005fe3,
0x14000000,
0x00050001,
0x0006002f,
0x00000000,
0x8b18039c,
0x8b110e61,
0x9102e3e2,
0xf9005ffc,
0x14000000,
0x00050001,
0x00060030,
0x8b110e61,
0x8b1c0e62,
0x0006000b,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030001,
0xb4000000,
0x00050803,
0xf9400008,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000d,
0xd1000269,
0x000b0000,
0xf84002f3,
0x000e0000,
0x5280021c,
0xf85f0262,
0xf81e8275,
0xcb090275,
0x92000042,
0x000d0000,
0x14000000,
0x00050026,
0x00060031,
0x93407d21,
0x94000000,
0x00030002,
0xaa1a03e8,
0xb4000000,
0x00050832,
0xf9400008,
0x14000000,
0x00050032,
0x00060033,
0x92800003,
0x00090205,
0x8b110e61,
0x8b03bf83,
0x14000000,
0x00050002,
0x00060034,
0xf2e00001,
0x00090205,
0xf80002c1,
0x000e0000,
0x00000000,
0x910002c1,
0x000b0000,
0x0006000c,
0x9102e3e2,
0xf9005fe3,
0x14000000,
0x00050001,
0x00060035,
0x8b18039c,
0x8b110e61,
0x9102e3e2,
0xf9005ffc,
0x14000000,
0x00050001,
0x00060036,
0x8b110e61,
0x8b1c0e62,
0x0006000b,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030003,
0xf87b7a68,
0xb4000000,
0x00050803,
0xf9000008,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000d,
0xd1000269,
0x000b0000,
0xf84002f3,
0x000e0000,
0x5280031c,
0xf85f0262,
0xf9000a68,
0xf81e8275,
0xcb090275,
0x92000042,
0x000d0000,
0x14000000,
0x00050026,
0x00060037,
0x93407d22,
0xf80002f3,
0x000e0000,
0xf90057f5,
0x94000000,
0x00030004,
0x14000000,
0x00050038,
0x00060039,
0x8b1b0e61,
0xd10012b5,
0x8b1c0e62,
0xf80002f3,
0x000e0000,
0x00000000,
0xaa1703e0,
0xf90057f5,
0x53001e03,
0x94000000,
0x00030005,
0x0006000d,
0xf100041f,
0x54000008,
0x0005083a,
0x0006000e,
0x794006b1,
0x910012b5,
0x8b110ab1,
0xd1408231,
0x9a9132b5,
0x0006002c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006003b,
0xb85fc2b0,
0xf9400368,
0xd3483e09,
0xf8297a68,
0x14000000,
0x0005002c,
0x0006003c,
0xf9400368,
0x92e00029,
0xeb08013f,
0x14000000,
0x0005000e,
0x0006003d,
0xf9400368,
0x92d00009,
0xeb09011f,
0x14000000,
0x0005000e,
0x0006003e,
0x92000042,
0x000d0000,
0xd10012b5,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030006,
0x14000000,
0x0005000d,
0x0006003f,
0xd10012b5,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xaa1003e1,
0xf90057f5,
0x94000000,
0x00030007,
0x14000000,
0x0005000d,
0x00060040,
0x00000000,
0xd10012b5,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xaa1b03e1,
0xaa1c03e2,
0xf90057f5,
0x94000000,
0x00030008,
0x14000000,
0x0005002c,
0x00060041,
0x8b110e62,
0x8b1c0e83,
0x14000000,
0x00050001,
0x00060042,
0x8b110e63,
0x8b1c0e82,
0x14000000,
0x00050001,
0x00060043,
0x8b1c0e62,
0xaa0203e3,
0x14000000,
0x00050001,
0x00060044,
0x8b110e62,
0x8b1c0e63,
0x0006000b,
0x53001e04,
0x8b1b0e61,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030009,
0xb4000000,
0x0005082c,
0x0006003a,
0xcb130009,
0xf81e8015,
0x91000135,
0x000b0000,
0xaa0003f3,
0x5280021c,
0x14000000,
0x00050024,
0x00060045,
0x8b1c0e61,
0x00000000,
0xaa0003fc,
0x00000000,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x0003000a,
0x00000000,
0xb5000000,
0x0005083a,
0xaa1c03e0,
0x14000000,
0x00050046,
0x00000000,
0x14000000,
0x0005003a,
0x00000000,
0x00060025,
0xaa1703e0,
0xf80002f1,
0x000e0000,
0xd1004261,
0xf90057f5,
0x8b1c0262,
0x94000000,
0x0003000b,
0xf85f0262,
0x9100239c,
0x92000042,
0x000d0000,
0xf81f8275,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00060047,
0xaa1703e0,
0xf80002f3,
0x000e0000,
0xd1004361,
0xf90057f5,
0x8b1c0362,
0x94000000,
0x0003000b,
0xf85f0369,
0xf85f8275,
0x9100239c,
0x92000122,
0x000d0000,
0x14000000,
0x00050048,
0x00060049,
0xaa1703e0,
0xf80002f3,
0x000e0000,
0xaa1b03e1,
0xf90057f5,
0x94000000,
0x0003000c,
0xb85fc2b0,
0x53001e08,
0xd3483e1b,
0xd3507e1c,
0xf100011f,
0x000b0000,
0x54000000,
0x00070800,
0x14000000,
0x00070000,
0x0006004a,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0xf85f8275,
0x92d00009,
0xeb09001f,
0x54000002,
0x0005084b,
0xf81f0260,
0xd1002271,
0xf100239b,
0x9100239c,
0xb400001b,
0x0005084c,
0x0006000b,
0x00000000,
0xf9400a20,
0xd100237b,
0xf8008620,
0xb500001b,
0x0005080b,
0x14000000,
0x0005004c,
0x0006004d,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x52800008,
0x00090205,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0xda8f3109,
0x91000129,
0x000b0000,
0xf8697840,
0x14000000,
0x0005004e,
0x0006004f,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0xba4019e4,
0x000900b0,
0x92000000,
0x000d0000,
0x54000001,
0x00050806,
0x0006000b,
0xf8400011,
0x000e0000,
0x0006000c,
0xaa1a03e0,
0xf84002dc,
0x000e0000,
0xb4000011,
0x0005084e,
0xb8400229,
0x000e0000,
0xb840038a,
0x000e0000,
0xf8400222,
0x000e0000,
0x00000000,
0x0a0a0129,
0x8b090529,
0x92800003,
0x00090205,
0x8b090c42,
0x8b03bf83,
0x0006000d,
0xa9402040,
0x00098cef,
0xf8400042,
0x000e0000,
0xeb03011f,
0x54000000,
0x00050805,
0xb5000002,
0x0005080d,
0x0006000e,
0xaa1103e0,
0xf2e00000,
0x00090205,
0x14000000,
0x0005004e,
0x0006000f,
0xeb1a011f,
0x54000001,
0x0005084e,
0x14000000,
0x0005000e,
0x00060010,
0x92800008,
0x00090205,
0xeb0801ff,
0x9a8821ef,
0xcb0f0ec9,
0xf8400131,
0x000e0000,
0x14000000,
0x0005000c,
0x00060050,
0xa9400660,
0xf100439f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000009,
0x000d0000,
0x54000001,
0x0005084b,
0xf8400128,
0x000e0000,
0x00000000,
0x936ffc2f,
0x3840012a,
0x000e0000,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0xfa400900,
0x54000001,
0x0005084b,
0xf8000121,
0x000e0000,
0x3610000a,
0x0005104e,
0xf84002c8,
0x000e0000,
0x1200014a,
0x000c0000,
0xf80002c9,
0x000e0000,
0x3800012a,
0x000e0000,
0xf8000128,
0x000e0000,
0x14000000,
0x0005004e,
0x00060051,
0xf9400261,
0xf100439f,
0x54000003,
0x0005084b,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x0005084b,
0xaa1703e0,
0x91002262,
0x94000000,
0x0003000d,
0xf9400000,
0x14000000,
0x0005004e,
0x00060052,
0xf9400260,
0xf100239f,
0x54000001,
0x0005084b,
0xeb40833f,
0x54000003,
0x0005084b,
0x00000000,
0x14000000,
0x0005004e,
0x00060053,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x54000000,
0x0005084e,
0xf84002c9,
0x000e0000,
0xf80002f3,
0x000e0000,
0xb10001ff,
0x000b0000,
0xfa409920,
0xf90057f5,
0x54000001,
0x0005084b,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0xaa1703e0,
0xaa1303e1,
0x94000000,
0x0003000e,
0x92800009,
0x00090205,
0xf84002f3,
0x000e0000,
0x8b09bc00,
0x14000000,
0x0005004e,
0x00060055,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000001,
0x000d0000,
0x54000001,
0x0005084b,
0x00000000,
0xf83c6a7a,
0xf85f8275,
0xa9004ef3,
0x00098cef,
0xaa1703e0,
0x91002262,
0xf90057f5,
0x94000000,
0x0003000f,
0xf81f027a,
0xb4000000,
0x00050856,
0xa9408660,
0x5280031c,
0xa93f0660,
0x14000000,
0x0005004c,
0x00060057,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000009,
0x000d0000,
0x54000001,
0x0005084b,
0x00000000,
0xf8400121,
0x000e0000,
0x00000000,
0xf8400043,
0x000e0000,
0xf85f8275,
0x00000000,
0xb5000001,
0x0005084b,
0x00000000,
0x5280041c,
0xa93fea60,
0xf81f0263,
0x14000000,
0x0005004c,
0x00060058,
0xa9400660,
0xf100439f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000000,
0x000d0000,
0x54000001,
0x0005084b,
0xeb41833f,
0x54000001,
0x0005084b,
0xb8400009,
0x000e0000,
0xf8400002,
0x000e0000,
0xb8400008,
0x000e0000,
0x11000421,
0x6b09003f,
0xf85f8275,
0x8b18002a,
0x5280011c,
0xf81f026a,
0x54000002,
0x00050802,
0xf8617848,
0x0006000b,
0x52800309,
0xeb1a011f,
0xf81f8268,
0x9a89039c,
0x14000000,
0x0005004c,
0x0006000c,
0x34000008,
0x0005084c,
0x94000000,
0x00030002,
0xb4000000,
0x0005084c,
0xf9400008,
0x14000000,
0x0005000b,
0x00060059,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000009,
0x000d0000,
0x00000000,
0x54000001,
0x0005084b,
0x00000000,
0xf8400121,
0x000e0000,
0x00000000,
0xf8400043,
0x000e0000,
0xf85f8275,
0x00000000,
0xb5000001,
0x0005084b,
0x00000000,
0x5280041c,
0xa93fe260,
0xf81f0263,
0x14000000,
0x0005004c,
0x0006005a,
0x384002c8,
0x000e0000,
0xf100239c,
0x54000003,
0x0005084b,
0xaa1303f1,
0x91004273,
0x53000108,
0x000900d0,
0x000900ca,
0x91000115,
0x000b0000,
0x54000000,
0x00050824,
0x0006000b,
0x8b1c026a,
0x0006000c,
0xf85f0148,
0xf81f8d48,
0xeb13015f,
0x54000001,
0x0005080c,
0x14000000,
0x00050024,
0x0006005b,
0xa9400660,
0x384002c8,
0x000e0000,
0xf100439c,
0x54000003,
0x0005084b,
0xaa1303f1,
0x91006273,
0x936ffc2f,
0x53000108,
0x000900d0,
0x000900ca,
0xb10001ff,
0x000b0000,
0x91000115,
0x000b0000,
0x54000001,
0x0005084b,
0xa9000221,
0xb400001c,
0x00050824,
0x14000000,
0x0005000b,
0x0006005c,
0x00000000,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000000,
0x000d0000,
0x54000001,
0x0005084b,
0xf85f8275,
0xf80002f3,
0x000e0000,
0xa9400411,
0x00098cef,
0x38400009,
0x000e0000,
0x8b090028,
0xf90057f5,
0xeb11011f,
0x54000000,
0x0005084b,
0xf100013f,
0x000b0000,
0x91002028,
0x9a882021,
0xf8400003,
0x000e0000,
0x8b1c0022,
0xf8400011,
0x000e0000,
0xfa439042,
0xfa409a22,
0x54000008,
0x0005084b,
0xd1002042,
0x91002273,
0xd100239c,
0xf8000002,
0x000e0000,
0xf80002f3,
0x000e0000,
0xb400001c,
0x00050803,
0x0006000c,
0xf8716a68,
0xeb1c023f,
0xf8316828,
0x91002231,
0x54000001,
0x0005080c,
0x0006000d,
0x52800002,
0xaa0003fb,
0x52800003,
0x94000000,
0x00050021,
0x0006000e,
0xa9400f62,
0x00098cef,
0xf100001f,
0x000b0000,
0x00000000,
0xf84002f3,
0x000e0000,
0xf80002d7,
0x000e0000,
0xb80002da,
0x000e0000,
0x54000008,
0x00050808,
0xcb02007c,
0xf84002e0,
0x000e0000,
0x8b1c0261,
0xb400001c,
0x00050806,
0xeb00003f,
0x52800011,
0x54000008,
0x00050809,
0xd1002383,
0xf8000362,
0x000e0000,
0x0006000f,
0xf8716848,
0xeb03023f,
0xf8316a68,
0x91002231,
0x54000001,
0x0005080f,
0x00060010,
0x92e00029,
0x9100439c,
0x00060011,
0xf81f8269,
0xd100227b,
0xf20002a0,
0x000d0000,
0xf90057f5,
0xb900c3fc,
0x54000000,
0x00050818,
0x14000000,
0x00050019,
0x00060012,
0xf85f8c68,
0x92d00009,
0x5280031c,
0xf8000363,
0x000e0000,
0xf9000268,
0x14000000,
0x00050011,
0x00060013,
0xaa1703e0,
0xd343ff81,
0x94000000,
0x00030000,
0x52800000,
0x14000000,
0x0005000e,
0x0006005d,
0x00000000,
0xf8400040,
0x000e0000,
0x92000000,
0x000d0000,
0xf85f8275,
0xf80002f3,
0x000e0000,
0xa9400411,
0x00098cef,
0x38400009,
0x000e0000,
0x8b090028,
0xf90057f5,
0xeb11011f,
0x54000000,
0x0005084b,
0xf100013f,
0x000b0000,
0x91002028,
0x9a882021,
0xf8400003,
0x000e0000,
0x8b1c0022,
0xf8400011,
0x000e0000,
0xfa439042,
0xfa409a22,
0x54000008,
0x0005084b,
0xf8000002,
0x000e0000,
0xf80002f3,
0x000e0000,
0xb400001c,
0x00050803,
0x0006000c,
0xf8716a68,
0xeb1c023f,
0xf8316828,
0x91002231,
0x54000001,
0x0005080c,
0x0006000d,
0x52800002,
0xaa0003fb,
0x52800003,
0x94000000,
0x00050021,
0x0006000e,
0xa9400f62,
0x00098cef,
0xf100001f,
0x000b0000,
0xf84002f3,
0x000e0000,
0xf80002d7,
0x000e0000,
0x00000000,
0xb80002da,
0x000e0000,
0x54000008,
0x00050808,
0xcb02007c,
0xf84002e0,
0x000e0000,
0x8b1c0261,
0xb400001c,
0x00050806,
0xeb00003f,
0x52800011,
0x54000008,
0x00050809,
0xd1002383,
0xf8000362,
0x000e0000,
0x0006000f,
0xf8716848,
0xeb03023f,
0xf8316a68,
0x91002231,
0x54000001,
0x0005080f,
0x00060010,
0xaa1303fb,
0x9100239c,
0xf20002a0,
0x000d0000,
0xf90057f5,
0xb900c3fc,
0x54000000,
0x00050818,
0x14000000,
0x00050019,
0x00060012,
0xaa1703e0,
0xaa1b03e1,
0x94000000,
0x00030010,
0x00060013,
0xaa1703e0,
0xd343ff81,
0x94000000,
0x00030000,
0x52800000,
0x14000000,
0x0005000e,
0x0006005e,
0xf84002e8,
0x000e0000,
0x8b1c0269,
0x52800000,
0x00090205,
0xa90026f3,
0x00098cef,
0x36000008,
0x0005104b,
0x00000000,
0xf80002ff,
0x000e0000,
0x380002e0,
0x000e0000,
0x14000000,
0x0005001b,
0x0006005f,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000000,
0x0005084e,
0x54000003,
0x0005084b,
0x1e654000,
0x14000000,
0x00050060,
0x00060061,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000000,
0x0005084e,
0x54000003,
0x0005084b,
0x1e64c000,
0x14000000,
0x00050060,
0x00060062,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000003,
0x0005084b,
0x92000000,
0x000d0000,
0x54000001,
0x0005084e,
0x4a807c01,
0xd2e83c02,
0x6b807c20,
0x8b180000,
0x9a825000,
0x0006004e,
0xf85f8275,
0xf81f0260,
0x00060056,
0x5280021c,
0x0006004c,
0xf20002a0,
0x000d0000,
0x00000000,
0xb900c3fc,
0xd100427b,
0x54000001,
0x00050819,
0xb85fc2b0,
0xd3587e11,
0x0006000f,
0xeb110f9f,
0x54000003,
0x00050806,
0xd3483e09,
0xcb090f73,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00060010,
0x8b1c0369,
0x9100239c,
0xf81f813a,
0x14000000,
0x0005000f,
0x00060063,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x1e61c000,
0x00060060,
0xf85f8275,
0xfc1f0260,
0x14000000,
0x00050056,
0x00060064,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000001,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030011,
0x14000000,
0x00050060,
0x00060065,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030012,
0x14000000,
0x00050060,
0x00060066,
0x00000000,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030013,
0x14000000,
0x00050060,
0x00060067,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030014,
0x14000000,
0x00050060,
0x00060068,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030015,
0x14000000,
0x00050060,
0x00060069,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030016,
0x14000000,
0x00050060,
0x0006006a,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x00000000,
0x94000000,
0x00030017,
0x14000000,
0x00050060,
0x0006006b,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030018,
0x14000000,
0x00050060,
0x0006006c,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x00030019,
0x14000000,
0x00050060,
0x0006006d,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001a,
0x14000000,
0x00050060,
0x0006006e,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001b,
0x14000000,
0x00050060,
0x0006006f,
0x00000000,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001c,
0x14000000,
0x00050060,
0x00060070,
0xa9400660,
0xf100439f,
0x6d400660,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0xeb41833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001d,
0x14000000,
0x00050060,
0x00060071,
0xa9400660,
0xf100439f,
0x6d400660,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0xeb41833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001e,
0x14000000,
0x00050060,
0x00060072,
0xa9400660,
0xf100439f,
0x6d400660,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0xeb41833f,
0x54000009,
0x0005084b,
0x94000000,
0x0003001f,
0x14000000,
0x00050060,
0x00060073,
0x00000000,
0xa9400660,
0xf100439f,
0x54000003,
0x0005084b,
0xfd400260,
0xeb40833f,
0x54000009,
0x0005084b,
0xeb41833f,
0x54000001,
0x0005084b,
0x93407c20,
0x94000000,
0x00030020,
0x14000000,
0x00050060,
0x00060074,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0x9102e3e0,
0x94000000,
0x00030021,
0xb940bbe1,
0xf85f8275,
0xfc1f0260,
0x5280031c,
0x8b180021,
0xf81f8261,
0x14000000,
0x0005004c,
0x00060075,
0xf9400260,
0xf100239f,
0xfd400260,
0x54000003,
0x0005084b,
0xeb40833f,
0x54000009,
0x0005084b,
0xd1004260,
0xf85f8275,
0x94000000,
0x00030022,
0x5280031c,
0xfc1f8260,
0x14000000,
0x0005004c,
0x00060076,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x8b1c0271,
0x9100227b,
0xeb40833f,
0x54000001,
0x00050804,
0x0006000b,
0xf9400361,
0xeb11037f,
0x54000002,
0x0005084e,
0xeb41833f,
0x54000001,
0x00050803,
0x6b01001f,
0x9100237b,
0x9a80c020,
0x14000000,
0x0005000b,
0x0006000d,
0x00000000,
0x1e620000,
0x54000003,
0x0005084b,
0xfd400361,
0x14000000,
0x00050006,
0x0006000e,
0xfd400260,
0x54000003,
0x0005084b,
0x0006000f,
0xf9400361,
0xfd400361,
0xeb11037f,
0x54000002,
0x00050860,
0xeb41833f,
0x54000009,
0x00050807,
0x00060010,
0x1e612000,
0x9100237b,
0x1e608c20,
0x14000000,
0x0005000f,
0x00060011,
0x1e620021,
0x54000003,
0x0005084b,
0x14000000,
0x00050010,
0x00060077,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x8b1c0271,
0x9100227b,
0xeb40833f,
0x54000001,
0x00050804,
0x0006000b,
0xf9400361,
0xeb11037f,
0x54000002,
0x0005084e,
0xeb41833f,
0x54000001,
0x00050803,
0x6b01001f,
0x9100237b,
0x9a80b020,
0x14000000,
0x0005000b,
0x0006000d,
0x1e620000,
0x54000003,
0x0005084b,
0xfd400361,
0x14000000,
0x00050006,
0x0006000e,
0x00000000,
0xfd400260,
0x54000003,
0x0005084b,
0x0006000f,
0xf9400361,
0xfd400361,
0xeb11037f,
0x54000002,
0x00050860,
0xeb41833f,
0x54000009,
0x00050807,
0x00060010,
0x1e612000,
0x9100237b,
0x1e603c20,
0x14000000,
0x0005000f,
0x00060011,
0x1e620021,
0x54000003,
0x0005084b,
0x14000000,
0x00050010,
0x00060078,
0xa97f8275,
0xf100239f,
0x936ffc0f,
0xba4009e0,
0x000900b0,
0x92000000,
0x000d0000,
0x54000001,
0x0005084b,
0x38400008,
0x000e0000,
0xb8400002,
0x000e0000,
0x8b180108,
0xf81f0268,
0x5280011c,
0xb4000002,
0x0005084c,
0x14000000,
0x00050056,
0x00060079,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0x00000000,
0xa97f8275,
0x7103fc1f,
0xfa489b80,
0x54000001,
0x0005084b,
0xeb40833f,
0x54000001,
0x0005084b,
0x52800022,
0xaa1303e1,
0x0006007a,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030023,
0x0006007b,
0xf84002f3,
0x000e0000,
0x92800009,
0x00090205,
0x8b09bc00,
0x14000000,
0x0005004e,
0x0006007c,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0xf9400260,
0xf9400a62,
0xf100439f,
0x92800011,
0x54000000,
0x00050801,
0x54000003,
0x0005084b,
0xeb42833f,
0x54000001,
0x0005084b,
0x93407c51,
0x0006000b,
0xf9400661,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000000,
0x000d0000,
0x54000001,
0x0005084b,
0xb8400009,
0x000e0000,
0x00000000,
0xeb41833f,
0x54000001,
0x0005084b,
0x93407c21,
0x8b09022a,
0xf100023f,
0x8b090028,
0x9a8aa631,
0xf100003f,
0x9a88a421,
0xf100023f,
0x9a9fa231,
0xf100043f,
0x9a9fa421,
0xeb09023f,
0x9a89d231,
0x91000000,
0x000b0000,
0xeb010222,
0x8b010001,
0x91000442,
0x5400000a,
0x0005087a,
0x910002c0,
0x000b0000,
0x92800009,
0x00090205,
0x8b09bc00,
0x14000000,
0x0005004e,
0x0006007d,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0xf9400261,
0xf100239f,
0x936ffc2f,
0xba4029e0,
0x000900b0,
0x92000021,
0x000d0000,
0x54000001,
0x0005084b,
0xf84002c8,
0x000e0000,
0x910002c0,
0x000b0000,
0xf80002f3,
0x000e0000,
0xf90057f5,
0xf80002d7,
0x000e0000,
0xf80002c8,
0x000e0000,
0x94000000,
0x00030024,
0x94000000,
0x00030025,
0x14000000,
0x0005007b,
0x0006007e,
0x00000000,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0xf9400261,
0xf100239f,
0x936ffc2f,
0xba4029e0,
0x000900b0,
0x92000021,
0x000d0000,
0x54000001,
0x0005084b,
0xf84002c8,
0x000e0000,
0x910002c0,
0x000b0000,
0xf80002f3,
0x000e0000,
0xf90057f5,
0xf80002d7,
0x000e0000,
0xf80002c8,
0x000e0000,
0x94000000,
0x00030026,
0x94000000,
0x00030025,
0x14000000,
0x0005007b,
0x0006007f,
0xa94006c0,
0x00098cef,
0xeb01001f,
0x5400000b,
0x00050801,
0x94000000,
0x00050054,
0x0006000b,
0xf9400261,
0xf100239f,
0x936ffc2f,
0xba4029e0,
0x000900b0,
0x92000021,
0x000d0000,
0x00000000,
0x54000001,
0x0005084b,
0xf84002c8,
0x000e0000,
0x910002c0,
0x000b0000,
0xf80002f3,
0x000e0000,
0xf90057f5,
0xf80002d7,
0x000e0000,
0xf80002c8,
0x000e0000,
0x94000000,
0x00030027,
0x94000000,
0x00030025,
0x14000000,
0x0005007b,
0x00060080,
0x54000009,
0x0005084b,
0x8b000001,
0x52808682,
0xcb41d442,
0xf100d45f,
0x54000008,
0x00050801,
0x92000021,
0x000d0000,
0xb2000021,
0x000d0000,
0xf100001f,
0x9ac22421,
0x5a815420,
0xd61f03c0,
0x0006000b,
0x52800000,
0xd61f03c0,
0x00060081,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x5280011b,
0x2a0003e8,
0x1000001e,
0x00052002,
0x0006000b,
0x00000000,
0xf87b6a60,
0xeb1c037f,
0x9100237b,
0x5400000a,
0x00050809,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x0a000108,
0x14000000,
0x0005000b,
0x00060082,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x5280011b,
0x2a0003e8,
0x1000001e,
0x00052002,
0x0006000b,
0xf87b6a60,
0xeb1c037f,
0x9100237b,
0x5400000a,
0x00050809,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x2a000108,
0x14000000,
0x0005000b,
0x00060083,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x5280011b,
0x2a0003e8,
0x1000001e,
0x00052002,
0x0006000b,
0x00000000,
0xf87b6a60,
0xeb1c037f,
0x9100237b,
0x5400000a,
0x00050809,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x4a000108,
0x14000000,
0x0005000b,
0x00060084,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x2a0003e8,
0x00060013,
0x8b180100,
0x14000000,
0x0005004e,
0x00060085,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x5ac00808,
0x8b180100,
0x14000000,
0x0005004e,
0x00060086,
0xf9400260,
0xf100239f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0x00000000,
0x2a2003e8,
0x8b180100,
0x14000000,
0x0005004e,
0x00060087,
0xa9400268,
0xf100439f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0xaa0003e9,
0xaa0803e0,
0x1000001e,
0x00052002,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x1ac92008,
0x8b180100,
0x14000000,
0x0005004e,
0x00060088,
0xa9400268,
0xf100439f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0xaa0003e9,
0xaa0803e0,
0x1000001e,
0x00052002,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x1ac92408,
0x8b180100,
0x14000000,
0x0005004e,
0x00060089,
0xa9400268,
0xf100439f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0x00000000,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0xaa0003e9,
0xaa0803e0,
0x1000001e,
0x00052002,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x1ac92808,
0x8b180100,
0x14000000,
0x0005004e,
0x0006008a,
0xa9400268,
0xf100439f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0xcb0003e9,
0xaa0803e0,
0x1000001e,
0x00052002,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x1ac92c08,
0x8b180100,
0x14000000,
0x0005004e,
0x0006008b,
0xa9400268,
0xf100439f,
0x54000003,
0x0005084b,
0x1000001e,
0x00052001,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000b,
0xaa0003e9,
0xaa0803e0,
0x1000001e,
0x00052002,
0xeb40833f,
0x54000001,
0x00050880,
0x0006000c,
0x00000000,
0x1ac92c08,
0x8b180100,
0x14000000,
0x0005004e,
0x0006004b,
0xa97f5662,
0xf84002ea,
0x000e0000,
0x8b1c0269,
0xa90026f3,
0x00098cef,
0x92000042,
0x000d0000,
0x91000129,
0x000b0000,
0xf8400042,
0x000e0000,
0xf90057f5,
0xeb0a013f,
0xaa1703e0,
0x54000008,
0x00050805,
0xd63f0040,
0xf84002f3,
0x000e0000,
0x7100001f,
0xd37df01c,
0xd100427b,
0x5400000c,
0x0005084c,
0x0006000b,
0xf84002e0,
0x000e0000,
0xf85f0262,
0xcb13001c,
0x54000001,
0x00050829,
0x92000042,
0x000d0000,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00060029,
0xf20002a8,
0x000d0000,
0x920002a9,
0x000d0000,
0x54000001,
0x00050803,
0x385fd2bb,
0xd37df37b,
0x91004369,
0x0006000d,
0xcb090271,
0x14000000,
0x00050024,
0x0006000f,
0x00000000,
0x52800001,
0x00090205,
0x94000000,
0x00030000,
0xf84002f3,
0x000e0000,
0xeb00001f,
0x14000000,
0x0005000b,
0x00060054,
0x8b1c0261,
0xaa1e03fb,
0xa90006f3,
0x00098cef,
0xf90057f5,
0xaa1703e0,
0x94000000,
0x00030028,
0xa94006f3,
0x00098cef,
0xf85f0262,
0xaa1b03fe,
0xcb13003c,
0x92000042,
0x000d0000,
0xd65f03c0,
0x0006008c,
0x384002c0,
0x000e0000,
0xf200001f,
0x000d0000,
0x54000001,
0x00050805,
0xb84002c1,
0x000e0000,
0xf200001f,
0x000d0000,
0x54000001,
0x00050801,
0x51000421,
0xf200001f,
0x000d0000,
0x54000000,
0x00050801,
0xb80002c1,
0x000e0000,
0x14000000,
0x00050001,
0x0006008d,
0x384002ca,
0x000e0000,
0x00000000,
0x3600000a,
0x000a0000,
0x00051001,
0x0006000f,
0xf8400128,
0x000e0000,
0xd61f0100,
0x0006008e,
0x384002ca,
0x000e0000,
0xb84002cb,
0x000e0000,
0x3700000a,
0x000a0000,
0x0005100f,
0x7200015f,
0x000c0000,
0x54000000,
0x0005080f,
0x5100056b,
0xb80002cb,
0x000e0000,
0x3400000b,
0x00050801,
0x3600000a,
0x000a0000,
0x0005100f,
0x0006000b,
0xaa1703e0,
0xf80002f3,
0x000e0000,
0xaa1503e1,
0x94000000,
0x00030029,
0x0006000d,
0xf84002f3,
0x000e0000,
0x0006000e,
0xb85fc2b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x00000000,
0xd3507e1c,
0xd61f0100,
0x0006008f,
0xf85d8060,
0x910012b5,
0xb900c3e0,
0x14000000,
0x0005000e,
0x00060090,
0xf85f0262,
0x910002c0,
0x000b0000,
0x92000042,
0x000d0000,
0xf90057f5,
0xf8400042,
0x000e0000,
0xaa1503e1,
0xf80002d7,
0x000e0000,
0x38400042,
0x000e0000,
0xf80002f3,
0x000e0000,
0x8b020e62,
0xf80002e2,
0x000e0000,
0x94000000,
0x0003002a,
0x14000000,
0x0005000d,
0x00060091,
0xaa1503e1,
0x14000000,
0x00050001,
0x00060092,
0xb24002a1,
0x0006000b,
0x8b1c0269,
0xf90057f5,
0xaa1703e0,
0xcb13037b,
0xa90026f3,
0x00098cef,
0x94000000,
0x0003002b,
0xa94026f3,
0x00098cef,
0xf90057ff,
0xf85f0262,
0x8b1b027b,
0xcb13013c,
0xb85fc2b0,
0x92000042,
0x000d0000,
0xd61f0000,
0x00060093,
0xb940c3f1,
0xb85fc2b0,
0xf85d8062,
0xf1002231,
0xd3483e1c,
0x92000042,
0x000d0000,
0x00000000,
0x54000000,
0x00050802,
0x0006000b,
0xf9400360,
0x9100237b,
0xf1002231,
0xf83c7a60,
0x9100079c,
0x54000001,
0x0005080b,
0x0006000c,
0xd3483e1b,
0xd3587e11,
0x8b11037b,
0x0006000d,
0xeb1c037f,
0x54000008,
0x00050809,
0x7840005b,
0x000e0000,
0x7840005c,
0x000e0000,
0x6b1b039f,
0x54000000,
0x0005082c,
0x7100039f,
0x54000001,
0x00070800,
0x52800000,
0x00090205,
0xb8206adb,
0x52800000,
0x00090205,
0xf8206ad7,
0xf80002f3,
0x000e0000,
0x910002c0,
0x000b0000,
0xaa1503e1,
0x94000000,
0x0003002c,
0xf84002f3,
0x000e0000,
0x14000000,
0x0005002c,
0x00060013,
0xf83c7a7a,
0x9100079c,
0x14000000,
0x0005000d,
0x00060094,
0x00000000,
0xaa1703e0,
0xf80002f3,
0x000e0000,
0xaa1503e1,
0x94000000,
0x0003002d,
0xf84002f3,
0x000e0000,
0xd10012b5,
0x14000000,
0x0005002c,
0x00000000,
0x00060095,
0xd10803ff,
0x6d0007e0,
0xa91007e0,
0x6d010fe2,
0xa9110fe2,
0x6d0217e4,
0xa91217e4,
0x6d031fe6,
0xa9131fe6,
0x6d0427e8,
0xa91427e8,
0x6d052fea,
0xa9152fea,
0x6d0637ec,
0xa91637ec,
0x6d073fee,
0xa9173fee,
0x6d0847f0,
0xa91847f0,
0x6d094ff2,
0xa9194ff2,
0x6d0a57f4,
0xa91a57f4,
0x6d0b5ff6,
0xa91b5ff6,
0x6d0c67f8,
0xa91c67f8,
0x6d0d6ffa,
0xa91d6ffa,
0x6d0e77fc,
0xa91e77fc,
0x6d0f7ffe,
0xf94103e0,
0x910803e2,
0x12800003,
0x00090205,
0xa91f0bff,
0xcb1e0000,
0xf84002d7,
0x000e0000,
0xd342fc00,
0xf84002d3,
0x000e0000,
0xd1000800,
0xb94003c1,
0xb80002c3,
0x000e0000,
0xf80002f3,
0x000e0000,
0x53055021,
0xb80002c0,
0x000e0000,
0xb80002c1,
0x000e0000,
0xf80002d7,
0x000e0000,
0xf80002df,
0x000e0000,
0x910002c0,
0x000b0000,
0x910003e1,
0x94000000,
0x0003002e,
0xf84002e1,
0x000e0000,
0xf84002f3,
0x000e0000,
0x9200003f,
0x000d0000,
0xf94057f5,
0xf9005bf7,
0x14000000,
0x00050001,
0x00060096,
0xf9405bf7,
0x0006000b,
0x7100001f,
0x5400000b,
0x00050809,
0xd37df01c,
0xf85f0261,
0xd2e00018,
0x00090205,
0xd2a00019,
0x00090205,
0x9280001a,
0x92000021,
0x000d0000,
0x00000000,
0xb900c3fc,
0xf80002f3,
0x000e0000,
0xf8400021,
0x000e0000,
0xf80002df,
0x000e0000,
0x12800003,
0x00090205,
0xf8400034,
0x000e0000,
0x394002b1,
0xb84046b0,
0xb80002c3,
0x000e0000,
0x7100023f,
0x000b0000,
0x8b300ec9,
0x54000002,
0x00050804,
0x0006000c,
0x7100023f,
0x000b0000,
0x8b310ec8,
0xf8400111,
0x000e0000,
0xd3483e1b,
0xd350fe08,
0x9a9c311c,
0x54000003,
0x00050805,
0xf85f0262,
0xd100239c,
0x8b1b0e7b,
0x92000042,
0x000d0000,
0x0006000f,
0xd61f0220,
0x0006000e,
0xf85f8260,
0xf2000001,
0x000d0000,
0x54000001,
0x0005080c,
0xb85fc002,
0xd3483c40,
0xcb000e61,
0xf85e0022,
0x92000042,
0x000d0000,
0xf8400042,
0x000e0000,
0xf8400054,
0x000e0000,
0x14000000,
0x0005000c,
0x00060013,
0x00000000,
0xcb0003e1,
0xaa1703e0,
0x94000000,
0x0003002f,
0x00060097,
0x4a010003,
0x7100007f,
0x4a807c02,
0x4a817c23,
0x4b807c42,
0x4b817c63,
0x1ac30840,
0x1b038800,
0x7a404804,
0x4b030002,
0x1a820000,
0x4a010002,
0x7100005f,
0x5a805400,
0xd65f03c0,
0x00060098,
0xa9b37bfd,
0x910003fd,
0xa90153f3,
0x6d0627e8,
0xa9025bf5,
0x6d072fea,
0xa90363f7,
0x6d0837ec,
0xa9046bf9,
0x6d093fee,
0xa90573fb,
0xf8400155,
0x000e0000,
0xaa0a03f6,
0x910343ea,
0xb80002a9,
0x000e0000,
0xa90006a0,
0x00098cef,
0x6d0006a0,
0x00098cef,
0xa9000ea2,
0x00098cef,
0x6d000ea2,
0x00098cef,
0xa90016a4,
0x00098cef,
0x6d0016a4,
0x00098cef,
0xa9001ea6,
0x00098cef,
0x6d001ea6,
0x00098cef,
0xf80002aa,
0x000e0000,
0xaa1503e0,
0xf90057f5,
0x910003e1,
0x94000000,
0x00030030,
0xa9407013,
0x00098cef,
0xd2e00018,
0x00090205,
0xd2a00019,
0x00090205,
0x9280001a,
0xaa0003f7,
0xf85f0262,
0xcb13039c,
0xb80002da,
0x000e0000,
0x92000042,
0x000d0000,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x00000000,
0x8b1b0e7b,
0xd61f0100,
0x00060028,
0xf84002d5,
0x000e0000,
0xa9000ef3,
0x00098cef,
0xf80002b7,
0x000e0000,
0xaa1503e0,
0xaa1b03e1,
0x94000000,
0x00030031,
0xa94006a0,
0x00098cef,
0x6d4006a0,
0x00098cef,
0x14000000,
0x0005001b,
0x00060099,
0xa9be7bfd,
0x910003fd,
0xf9000bf3,
0xaa0003f3,
0xb8400008,
0x000e0000,
0x38400269,
0x000e0000,
0x9100026a,
0x000b0000,
0xf1000529,
0xf840026b,
0x000e0000,
0xcb2863bf,
0x54000004,
0x00050802,
0x0006000b,
0xf8697948,
0xf8297be8,
0xf1000529,
0x54000005,
0x0005080b,
0x0006000c,
0xa9400660,
0x00098cef,
0x6d400660,
0x00098cef,
0xa9400e62,
0x00098cef,
0x6d400e62,
0x00098cef,
0xa9401664,
0x00098cef,
0x00000000,
0x6d401664,
0x00098cef,
0xa9401e66,
0x00098cef,
0x6d401e66,
0x00098cef,
0xf8400268,
0x000e0000,
0xd63f0160,
0x910003bf,
0xa9000660,
0x00098cef,
0x6d000660,
0x00098cef,
0x6d000e62,
0x00098cef,
0xf9400bf3,
0xa8c27bfd,
0xd65f03c0,
0x00000000,
0x00080000,
0x00000000,
0xf87b7a60,
0x794006b1,
0xf87c7a61,
0x910012b5,
0x8b110ab1,
0xd1408231,
0xeb40833f,
0x54000001,
0x00050803,
0xeb41833f,
0x54000001,
0x00050804,
0x6b01001f,
0x00000000,
0x9a95b235,
0x00000000,
0x9a95a235,
0x00000000,
0x9a95d235,
0x00000000,
0x9a95c235,
0x00000000,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000d,
0xfc7b7a60,
0x54000003,
0x00050839,
0xfc7c7a61,
0xeb41833f,
0x54000008,
0x00050805,
0x54000001,
0x00050839,
0x1e620021,
0x14000000,
0x00050005,
0x0006000e,
0xfc7c7a61,
0x54000003,
0x00050839,
0x1e620000,
0x0006000f,
0x1e612000,
0x00000000,
0x9a953235,
0x00000000,
0x9a952235,
0x00000000,
0x9a959235,
0x00000000,
0x9a958235,
0x00000000,
0x14000000,
0x0005000b,
0x00000000,
0xf87b7a60,
0x8b1c0e7c,
0x794006b1,
0xf9400382,
0x910012b5,
0x8b110ab1,
0xd1408231,
0x936ffc4f,
0xb10001ff,
0x000b0000,
0x00000000,
0x54000009,
0x0005089a,
0x00000000,
0x54000009,
0x0005089b,
0x00000000,
0x936ffc08,
0xb10001ff,
0x000b0000,
0xba401904,
0x000900b0,
0x54000000,
0x0005083f,
0xeb02001f,
0x54000001,
0x00050802,
0x00000000,
0x0006009c,
0xaa1103f5,
0x00000000,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000c,
0xeb0801ff,
0xba4009e2,
0x000900b0,
0x00000000,
0x54000008,
0x0005080b,
0x00000000,
0x54000008,
0x0005089c,
0x00000000,
0x92000001,
0x000d0000,
0xf840002a,
0x000e0000,
0x00000000,
0xb400000a,
0x0005080b,
0x38400149,
0x000e0000,
0x52800003,
0x37000009,
0x000a0000,
0x0005100b,
0x00000000,
0xb400000a,
0x0005089c,
0x38400149,
0x000e0000,
0x52800023,
0x37000009,
0x000a0000,
0x0005109c,
0x00000000,
0x14000000,
0x0005003e,
0x00000000,
0xf87b7a60,
0xaa3c03fc,
0x794006b1,
0xf87c7a81,
0x910012b5,
0x92800008,
0x00090205,
0x936ffc0f,
0x8b110ab1,
0x8b08bc21,
0xd1408231,
0xb10001ff,
0x000b0000,
0x54000000,
0x0005083f,
0xeb01001f,
0x00000000,
0x9a950235,
0x00000000,
0x9a951235,
0x00000000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87b7a60,
0x8b1c0e9c,
0x794006b1,
0xf9400382,
0x910012b5,
0x8b110ab1,
0xd1408231,
0x00000000,
0x0006009a,
0x00000000,
0x0006009b,
0x00000000,
0xeb40833f,
0x54000001,
0x00050804,
0xeb42833f,
0x54000001,
0x00050806,
0x6b02001f,
0x0006000b,
0x00000000,
0x9a950235,
0x0006000c,
0x00000000,
0x0006000c,
0x9a951235,
0x00000000,
0x0006000d,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000e,
0x54000003,
0x00050807,
0xfc7b7a60,
0xfd400381,
0xeb42833f,
0x54000001,
0x00050805,
0x1e620041,
0x0006000f,
0x1e612000,
0x14000000,
0x0005000b,
0x00060010,
0xfd400381,
0x1e620000,
0x1e612000,
0x14000000,
0x0005000b,
0x00060011,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x54000001,
0x0005080c,
0x14000000,
0x0005003f,
0x00000000,
0xf87b7a68,
0x794006b1,
0x910012b5,
0x9100079c,
0x8b110ab1,
0x936ffd0f,
0xb10001ff,
0x000b0000,
0x54000000,
0x0005083f,
0xab0f039f,
0xd1408231,
0x00000000,
0x9a950235,
0x00000000,
0x9a951235,
0x00000000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0x794006b1,
0xf87c7a68,
0x910012b5,
0x92d00009,
0x8b110ab1,
0xeb09011f,
0xd1408231,
0x00000000,
0x9a9c337b,
0x00000000,
0x9a953235,
0x00000000,
0x9a9c237b,
0x00000000,
0x9a952235,
0x00000000,
0xf83b7a68,
0x00000000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87b7a68,
0xab88bf9f,
0x54000001,
0x00050840,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87b6a68,
0xeb48833f,
0x54000009,
0x00050840,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87c7a68,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87c7a68,
0x92d00009,
0x92e0002a,
0xeb09011f,
0x9a8a3128,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87c7a68,
0x936ffd0f,
0xb10001ff,
0x000b0000,
0x54000008,
0x00050843,
0xd2000108,
0x000d0000,
0x54000001,
0x00050805,
0x6b0803e8,
0xd2e83c02,
0x8b180108,
0x9a827108,
0x0006000f,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87c7a60,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000000,
0x000d0000,
0x54000001,
0x00050802,
0xb8400000,
0x000e0000,
0x0006000b,
0x8b180000,
0xf83b7a60,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000c,
0xb10001ff,
0x000b0000,
0x54000001,
0x00050845,
0x00000000,
0xf8400001,
0x000e0000,
0xb5000001,
0x00050809,
0x0006000d,
0x00000000,
0x00060046,
0x94000000,
0x00030032,
0x14000000,
0x0005000b,
0x00000000,
0x00060013,
0x38400029,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100d,
0x14000000,
0x00050045,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xeb40833f,
0x54000001,
0x00050805,
0xeb41833f,
0x54000001,
0x00050805,
0x2b010000,
0x00000000,
0x54000006,
0x00050841,
0x00000000,
0x54000006,
0x00050842,
0x00000000,
0x54000006,
0x00050844,
0x00000000,
0x8b180000,
0xf83b7a60,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x1e612800,
0xfc3b7a60,
0x14000000,
0x0005000e,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xeb40833f,
0x54000001,
0x00050805,
0xeb41833f,
0x54000001,
0x00050805,
0x6b010000,
0x00000000,
0x54000006,
0x00050841,
0x00000000,
0x54000006,
0x00050842,
0x00000000,
0x54000006,
0x00050844,
0x00000000,
0x8b180000,
0xf83b7a60,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x1e613800,
0xfc3b7a60,
0x14000000,
0x0005000e,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xeb40833f,
0x54000001,
0x00050805,
0xeb41833f,
0x54000001,
0x00050805,
0x9b217c00,
0xeb20c01f,
0x2a0003e0,
0x00000000,
0x54000001,
0x00050841,
0x00000000,
0x54000001,
0x00050842,
0x00000000,
0x54000001,
0x00050844,
0x00000000,
0x8b180000,
0xf83b7a60,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x1e610800,
0xfc3b7a60,
0x14000000,
0x0005000e,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x1e611800,
0xfc3b7a60,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xeb40833f,
0x54000001,
0x00050805,
0xeb41833f,
0x54000001,
0x00050805,
0x00000000,
0x34000001,
0x00050841,
0x00000000,
0x34000001,
0x00050842,
0x00000000,
0x34000001,
0x00050844,
0x00000000,
0x94000000,
0x00050097,
0x8b180000,
0xf83b7a60,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x1e611802,
0x1e654042,
0x1f418040,
0xfc3b7a60,
0x14000000,
0x0005000e,
0x00000000,
0x92401f9c,
0xd3587e11,
0x00000000,
0xd3587e11,
0x92401f9c,
0x00000000,
0xf8717a60,
0xf87c7a81,
0x00000000,
0xf87c7a80,
0xf8717a61,
0x00000000,
0xf8717a60,
0xf87c7a61,
0x00000000,
0xfc717a60,
0xfc7c7a81,
0x00000000,
0xfc7c7a80,
0xfc717a61,
0x00000000,
0xfc717a60,
0xfc7c7a61,
0x00000000,
0xeb40833f,
0x54000009,
0x00050841,
0xeb41833f,
0x54000009,
0x00050841,
0x00000000,
0xeb40833f,
0x54000009,
0x00050842,
0xeb41833f,
0x54000009,
0x00050842,
0x00000000,
0xeb40833f,
0x54000009,
0x00050844,
0xeb41833f,
0x54000009,
0x00050844,
0x00000000,
0x94000000,
0x0003001d,
0xfc3b7a60,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf80002f3,
0x000e0000,
0xcb110382,
0x8b1c0e61,
0x0006002b,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x00030033,
0x385ff2b1,
0xf84002f3,
0x000e0000,
0xb5000000,
0x0005083a,
0xf8717a68,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xaa3c03fc,
0xf87c7a88,
0x92800009,
0x00090205,
0x8b09bd08,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xaa3c03fc,
0xf87c7a88,
0x92800009,
0x00090205,
0x8b09bd08,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0x13003f9c,
0x8b180388,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf87c7a88,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xaa3cbfe8,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0x8b1b0e7b,
0x8b1c0e7c,
0xf800877a,
0x0006000b,
0xeb1c037f,
0xf800877a,
0x5400000b,
0x0005080b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf85f0261,
0x9100039c,
0x000b0000,
0x92000021,
0x000d0000,
0xf87c7821,
0xf8400021,
0x000e0000,
0xf9400028,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf85f0261,
0x9100037b,
0x000b0000,
0x92000021,
0x000d0000,
0xf87b7820,
0xf87c7a62,
0xf8400001,
0x000e0000,
0x3840000a,
0x000e0000,
0x38400008,
0x000e0000,
0x936ffc4f,
0xf9000022,
0x910001ef,
0x000b0000,
0x7200015f,
0x000c0000,
0x7a401904,
0xba4019e0,
0x000900b0,
0x54000008,
0x00050802,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000c,
0x92000042,
0x000d0000,
0x38400049,
0x000e0000,
0x7200013f,
0x000c0000,
0x54000000,
0x0005080b,
0xaa1603e0,
0x94000000,
0x00030034,
0x14000000,
0x0005000b,
0x00000000,
0xf85f0261,
0x9100037b,
0x000b0000,
0xaa3c03fc,
0x92000021,
0x000d0000,
0xf87b7820,
0xf87c7a82,
0x92800008,
0x00090205,
0xf8400001,
0x000e0000,
0x3840000a,
0x000e0000,
0x8b08bc48,
0x38400049,
0x000e0000,
0xf9000028,
0x3710000a,
0x00051002,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000c,
0x38400008,
0x000e0000,
0x7200013f,
0x000c0000,
0x7a401900,
0x54000000,
0x0005080b,
0xaa1603e0,
0x94000000,
0x00030034,
0x14000000,
0x0005000b,
0x00000000,
0xf85f0261,
0x9100037b,
0x000b0000,
0x92000021,
0x000d0000,
0xf87b7821,
0xf87c7a88,
0xf8400021,
0x000e0000,
0xf9000028,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf85f0261,
0x9100037b,
0x000b0000,
0x92000021,
0x000d0000,
0xf87b7821,
0xaa3cbfe8,
0xf8400021,
0x000e0000,
0xf9000028,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf84002e2,
0x000e0000,
0x8b1c0abc,
0xf80002f3,
0x000e0000,
0xd1408395,
0xb4000002,
0x00050801,
0xaa1703e0,
0x8b1b0e61,
0x94000000,
0x00030035,
0xf84002f3,
0x000e0000,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xaa3c03fc,
0xf80002f3,
0x000e0000,
0xf85f0262,
0xf90057f5,
0xf87c7a81,
0xaa1703e0,
0x92000042,
0x000d0000,
0x94000000,
0x00030036,
0xf84002f3,
0x000e0000,
0x92800008,
0x00090205,
0x8b08bc00,
0xf83b7a60,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xa9400ec2,
0x00098cef,
0xf80002f3,
0x000e0000,
0xf90057f5,
0xaa1703e0,
0xeb03005f,
0x54000002,
0x00050805,
0x0006000b,
0x00000000,
0x92402b81,
0xd34bff82,
0xf11ffc3f,
0x52810028,
0x9a881021,
0x94000000,
0x00030037,
0x00000000,
0xaa3c03fc,
0xf87c7a81,
0x94000000,
0x00030038,
0x00000000,
0xf84002f3,
0x000e0000,
0xf2e00000,
0x00090205,
0xf83b7a60,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x94000000,
0x00030039,
0xaa1703e0,
0x14000000,
0x0005000b,
0x00000000,
0xf85f0260,
0xaa3c03fc,
0x92000000,
0x000d0000,
0xf8400001,
0x000e0000,
0xf87c7a9c,
0x00000000,
0x14000000,
0x0005009d,
0x00000000,
0x14000000,
0x0005009e,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0xf87c7a69,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x00050830,
0xeb49833f,
0x54000001,
0x00050809,
0xf8400022,
0x000e0000,
0xb8400020,
0x000e0000,
0x8b294c42,
0x6b00013f,
0x54000002,
0x00050830,
0xf9400048,
0xeb1a011f,
0x54000000,
0x00050805,
0x0006000b,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf8400020,
0x000e0000,
0xb4000000,
0x0005080b,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100b,
0x14000000,
0x00050030,
0x00060013,
0x936ffd2f,
0xb10001ff,
0x000b0000,
0x54000001,
0x00050830,
0x9200013c,
0x000d0000,
0x14000000,
0x0005009d,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0xaa3c03fc,
0xf87c7a9c,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x0005082d,
0x0006009d,
0xb8400029,
0x000e0000,
0xb840038a,
0x000e0000,
0xf8400022,
0x000e0000,
0x0a0a0129,
0x8b090529,
0x92800003,
0x00090205,
0x8b090c42,
0x8b03bf83,
0x0006000b,
0xa9400048,
0x00098cef,
0xf8400042,
0x000e0000,
0xeb03001f,
0x54000001,
0x00050804,
0xeb1a011f,
0x54000000,
0x00050805,
0x0006000d,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000e,
0xb5000002,
0x0005080b,
0xaa1a03e8,
0x0006000f,
0xf8400020,
0x000e0000,
0xb4000000,
0x0005080d,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100d,
0x00000000,
0x14000000,
0x0005002e,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x0005082f,
0xf8400022,
0x000e0000,
0xb8400020,
0x000e0000,
0x8b1c0c42,
0x6b00039f,
0x54000002,
0x0005082f,
0xf9400048,
0xeb1a011f,
0x54000000,
0x00050805,
0x0006000b,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf8400020,
0x000e0000,
0xb4000000,
0x0005080b,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100b,
0x14000000,
0x0005002f,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a60,
0xf87c7a69,
0x92000000,
0x000d0000,
0xf8400002,
0x000e0000,
0xb840000a,
0x000e0000,
0x8b294c42,
0x6b0a013f,
0x54000002,
0x00050831,
0xf9400048,
0x00060032,
0xf83b7a68,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0xf87c7a69,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x00050836,
0xeb49833f,
0x54000001,
0x00050809,
0xf8400022,
0x000e0000,
0xb8400020,
0x000e0000,
0x8b294c42,
0x6b00013f,
0x54000002,
0x00050836,
0xf9400049,
0xf87b7a68,
0x3840002a,
0x000e0000,
0xeb1a013f,
0x54000000,
0x00050805,
0x0006000b,
0xf9000048,
0x3710000a,
0x00051007,
0x0006000c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf8400020,
0x000e0000,
0xb4000000,
0x0005080b,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100b,
0x14000000,
0x00050036,
0x00060011,
0xf84002c9,
0x000e0000,
0x00000000,
0x1200014a,
0x000c0000,
0xf80002c1,
0x000e0000,
0x3800002a,
0x000e0000,
0xf8000029,
0x000e0000,
0x14000000,
0x0005000c,
0x00060013,
0x936ffd2f,
0xb10001ff,
0x000b0000,
0x54000001,
0x00050836,
0x9200013c,
0x000d0000,
0x14000000,
0x0005009e,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0xaa3c03fc,
0xf87c7a9c,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x00050833,
0x0006009e,
0xb8400029,
0x000e0000,
0xb840038a,
0x000e0000,
0xf8400022,
0x000e0000,
0x0a0a0129,
0x8b090529,
0x92800003,
0x00090205,
0x8b090c42,
0x8b03bf83,
0x3800003f,
0x000e0000,
0x0006000b,
0xa9400049,
0x00098cef,
0xf840004b,
0x000e0000,
0x3840002a,
0x000e0000,
0xeb03001f,
0x54000001,
0x00050805,
0xf87b7a68,
0xeb1a013f,
0x54000000,
0x00050804,
0x0006000c,
0xf8000048,
0x000e0000,
0x3710000a,
0x00051007,
0x0006000d,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000e,
0xf8400020,
0x000e0000,
0x00000000,
0xb4000000,
0x0005080c,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100c,
0x14000000,
0x00050034,
0x0006000f,
0xaa0b03e2,
0xb500000b,
0x0005080b,
0xf8400020,
0x000e0000,
0xb4000000,
0x00050806,
0x38400009,
0x000e0000,
0x36000009,
0x000a0000,
0x00051034,
0x00060010,
0x92800009,
0x00090205,
0xf90057f5,
0x8b09bf88,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf9005fe8,
0x9102e3e2,
0x94000000,
0x0003003a,
0xf84002f3,
0x000e0000,
0xf87b7a68,
0xf9000008,
0x14000000,
0x0005000d,
0x00060011,
0xf84002c9,
0x000e0000,
0x1200014a,
0x000c0000,
0xf80002c1,
0x000e0000,
0x00000000,
0x3800002a,
0x000e0000,
0xf8000029,
0x000e0000,
0x14000000,
0x0005000d,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0x936ffc2f,
0xb10001ff,
0x000b0000,
0x92000021,
0x000d0000,
0x54000001,
0x00050835,
0xf8400022,
0x000e0000,
0xb8400020,
0x000e0000,
0x8b1c0c42,
0x6b00039f,
0x54000002,
0x00050835,
0xf9400049,
0xf87b7a68,
0x3840002a,
0x000e0000,
0xeb1a013f,
0x54000000,
0x00050805,
0x0006000b,
0xf9000048,
0x3710000a,
0x00051007,
0x0006000c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf8400020,
0x000e0000,
0xb4000000,
0x0005080b,
0x38400009,
0x000e0000,
0x37000009,
0x000a0000,
0x0005100b,
0x14000000,
0x00050035,
0x00060011,
0xf84002c9,
0x000e0000,
0x1200014a,
0x000c0000,
0x00000000,
0xf80002c1,
0x000e0000,
0x3800002a,
0x000e0000,
0xf8000029,
0x000e0000,
0x14000000,
0x0005000c,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf8717a61,
0xf87c7a69,
0x92000021,
0x000d0000,
0xf8400020,
0x000e0000,
0x3840002a,
0x000e0000,
0xb8400023,
0x000e0000,
0x8b294c00,
0x3710000a,
0x00051007,
0x0006000c,
0x6b03013f,
0x54000002,
0x00050837,
0x00060038,
0xf87b7a68,
0xf9000008,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00060011,
0xf84002c8,
0x000e0000,
0x1200014a,
0x000c0000,
0xf80002c1,
0x000e0000,
0x3800002a,
0x000e0000,
0xf8000028,
0x000e0000,
0x14000000,
0x0005000c,
0x00000000,
0x8b1b0e7b,
0x0006000b,
0xb940c3f1,
0xf85f8361,
0xf87c7a89,
0xd1002231,
0xb4000011,
0x00050804,
0x92000021,
0x000d0000,
0xb8400020,
0x000e0000,
0x0b510d22,
0xf8400023,
0x000e0000,
0xeb00005f,
0x8b110371,
0x54000008,
0x00050805,
0x8b294c69,
0x3840002a,
0x000e0000,
0x0006000d,
0xf8408768,
0xf8008528,
0xeb11037f,
0x54000003,
0x0005080d,
0x3710000a,
0x00051007,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf80002f3,
0x000e0000,
0xaa1703e0,
0xf90057f5,
0x94000000,
0x0003003b,
0x14000000,
0x0005000b,
0x00060011,
0xf84002c9,
0x000e0000,
0x1200014a,
0x000c0000,
0xf80002c1,
0x000e0000,
0x3800002a,
0x000e0000,
0xf8000029,
0x000e0000,
0x00000000,
0x14000000,
0x0005000e,
0x00000000,
0xb940c3e8,
0xd37d1f9c,
0x8b08039c,
0x14000000,
0x0005009f,
0x00000000,
0xd37d1f9c,
0x0006009f,
0xaa1303f1,
0x8b1b0e73,
0xf9400262,
0xd100239c,
0x91004273,
0x936ffc4f,
0xb10001ff,
0x000b0000,
0x92000042,
0x000d0000,
0x54000001,
0x00050825,
0xf81f8275,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00000000,
0xb940c3e8,
0x8b1c0d1c,
0x14000000,
0x000500a0,
0x00000000,
0xd37df39c,
0x000600a0,
0x8b1b0e7b,
0xf9400369,
0xd100239c,
0x9100437b,
0x936ffd2f,
0xb10001ff,
0x000b0000,
0x92000122,
0x000d0000,
0x54000001,
0x00050847,
0xf85f8275,
0x00060048,
0x52800011,
0x3840004a,
0x000e0000,
0xf20002bf,
0x000d0000,
0x54000001,
0x00050807,
0x0006000b,
0xf81f0269,
0xb400001c,
0x00050803,
0x0006000c,
0xf8716b68,
0x91002229,
0xeb1c013f,
0xf8316a68,
0xaa0903f1,
0x54000001,
0x0005080c,
0x0006000d,
0xf100055f,
0x54000008,
0x00050805,
0x0006000e,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x0006000f,
0x385fd2bb,
0xcb1b0e60,
0xf85e0000,
0x92000000,
0x000d0000,
0xf8400000,
0x000e0000,
0xf8400014,
0x000e0000,
0x14000000,
0x0005000e,
0x00060011,
0x00000000,
0xd20002b5,
0x000d0000,
0xf20002bf,
0x000d0000,
0x9a8a122a,
0x54000001,
0x0005080b,
0xcb150273,
0xf85f8275,
0xf20002bf,
0x000d0000,
0x9a8a122a,
0x14000000,
0x0005000b,
0x00000000,
0x8b1b0e7b,
0xf85e8362,
0xaa1303f1,
0xa97f0760,
0x91004373,
0x5280021c,
0xf9000362,
0xa9010760,
0x936ffc4f,
0xb10001ff,
0x000b0000,
0x92000042,
0x000d0000,
0x54000001,
0x00050825,
0xf81f8275,
0xf8400055,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0x8b1b0e7b,
0xd61f0100,
0x00000000,
0x8b1b0e7b,
0xf85f0371,
0x794006ab,
0xb85f8360,
0x910012b5,
0x8b0b0aab,
0x92000231,
0x000d0000,
0xd140816b,
0xb8400229,
0x000e0000,
0xf8400221,
0x000e0000,
0x0006000b,
0xeb09001c,
0x8b000c22,
0x54000002,
0x00050805,
0xf9400048,
0xeb1a011f,
0x9a801400,
0x54000000,
0x0005080b,
0x8b180000,
0xa9002360,
0x91000400,
0x0006000d,
0xb81f8360,
0xaa0b03f5,
0x0006000e,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xb840022a,
0x000e0000,
0xf8400231,
0x000e0000,
0x00060010,
0x8b1c0780,
0xeb0a039f,
0x8b000e22,
0x54000008,
0x0005080e,
0xa9400048,
0x00098cef,
0xeb1a011f,
0x9100079c,
0x54000000,
0x00050810,
0xa9002360,
0x8b090380,
0x14000000,
0x0005000d,
0x00000000,
0x8b1b0e7b,
0xf85e8360,
0x8b1c0abc,
0xa97f0f62,
0xd140839c,
0x936ffc0f,
0xb10001ff,
0x000b0000,
0x92000000,
0x000d0000,
0x54000001,
0x00050805,
0x936ffc48,
0x38400009,
0x000e0000,
0xb100011f,
0x000b0000,
0xfa5a0060,
0x7a400920,
0x000900b0,
0x54000001,
0x00050805,
0x320f77e8,
0xd3607d08,
0xf81f8368,
0x0006000b,
0xaa1c03f5,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0x52800008,
0x00090205,
0x52800009,
0x00090205,
0x381fc2a8,
0x39000389,
0x14000000,
0x0005000b,
0x00000000,
0xd3587e11,
0x92401f9c,
0xf85f8269,
0x8b1c0e7c,
0x8b1b0e7b,
0x9100039c,
0x000b0000,
0x8b110f6a,
0xcb09039c,
0xd100426b,
0xb4000011,
0x00050805,
0xd100414a,
0x0006000b,
0xeb0b039f,
0xf8408788,
0x9a9a3108,
0xeb0a037f,
0xf8008768,
0x54000003,
0x0005080b,
0x0006000c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000f,
0xf84002e8,
0x000e0000,
0xeb1c016a,
0x9a8ad3f1,
0x91002231,
0x8b0a0369,
0xb900c3f1,
0x5400000d,
0x0005080c,
0xeb08013f,
0x54000008,
0x00050807,
0x00060010,
0xf8408788,
0xf8008768,
0xeb0b039f,
0x54000003,
0x00050810,
0x14000000,
0x0005000c,
0x00060011,
0xd343fd41,
0xa9006ef3,
0x00098cef,
0xaa1703e0,
0xcb13039c,
0xf90057f5,
0x94000000,
0x00030000,
0xa9406ef3,
0x00098cef,
0x8b1c027c,
0xd100426b,
0x14000000,
0x00050010,
0x00000000,
0xb940c3e8,
0xf85f8275,
0x8b1b0e7b,
0x8b1c0d1c,
0x14000000,
0x000500a1,
0x00000000,
0xf85f8275,
0xd37df39c,
0x8b1b0e7b,
0x000600a1,
0xb900c3fc,
0x0006000b,
0xf20002a0,
0x000d0000,
0xd20002a1,
0x000d0000,
0x54000001,
0x000508a2,
0x00060018,
0xb85fc2b0,
0xf1002389,
0xd1004262,
0x54000000,
0x00050803,
0x0006000c,
0xf8408768,
0x91002273,
0xd1002129,
0xf81e8268,
0xb5000009,
0x0005080c,
0x0006000d,
0xd3483e1b,
0xcb1b0c43,
0xd3587e11,
0xf85f0060,
0x0006000f,
0xeb110f9f,
0x54000003,
0x00050806,
0x92000000,
0x000d0000,
0xaa0303f3,
0xf8400001,
0x000e0000,
0xf8400034,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00060010,
0x91002273,
0x9100239c,
0xf81e827a,
0x14000000,
0x0005000f,
0x000600a3,
0x8b1b0e7b,
0x000600a2,
0xf200003f,
0x000d0000,
0x54000001,
0x00050819,
0x00000000,
0xcb010273,
0xf85f8275,
0x14000000,
0x0005000b,
0x00000000,
0xf85f8275,
0xd37df39c,
0xb900c3fc,
0xf20002a0,
0x000d0000,
0xd20002a1,
0x000d0000,
0x54000001,
0x000508a3,
0xb85fc2b0,
0x00000000,
0xf87b7a68,
0x00000000,
0xd1004263,
0xd3483e1b,
0xcb1b0c73,
0x00000000,
0xf8008468,
0x00000000,
0xd3587e11,
0xf85f0260,
0x0006000f,
0xeb110f9f,
0x54000003,
0x00050806,
0x92000000,
0x000d0000,
0xf8400001,
0x000e0000,
0xf8400034,
0x000e0000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00060010,
0x9100239c,
0xf800847a,
0x14000000,
0x0005000f,
0x00000000,
0xd341fea0,
0x927f1400,
0x91000000,
0x000b0000,
0x78606ac1,
0xf1000021,
0x000b0000,
0x78206ac1,
0x54000003,
0x00050890,
0x00000000,
0x8b1b0e7b,
0xa9400760,
0xf9400b62,
0x00000000,
0x8b1c0abc,
0xd140839c,
0x00000000,
0xeb40833f,
0x54000001,
0x00050805,
0x00000000,
0xeb41833f,
0x54000001,
0x00050849,
0xeb42833f,
0x54000001,
0x00050849,
0x37f80002,
0x00051004,
0x6b01001f,
0x00000000,
0x2b020000,
0x54000006,
0x00050802,
0x8b180008,
0x37f80002,
0x00051004,
0x6b01001f,
0x00000000,
0x0006000b,
0x00000000,
0x9a95c395,
0x00000000,
0xaa1c03f5,
0x785fe39c,
0x00000000,
0x9a95d395,
0x00000000,
0xf9000368,
0xf9000f68,
0x00000000,
0xf9000f60,
0x00000000,
0x5400000d,
0x00070800,
0x00000000,
0x0006000c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000e,
0x6b00003f,
0x14000000,
0x0005000b,
0x0006000f,
0x6d400760,
0x54000003,
0x00050849,
0x00000000,
0xeb41833f,
0x54000009,
0x00050849,
0xeb42833f,
0x54000009,
0x00050849,
0xfd000f60,
0x00000000,
0xfd400b62,
0x1e622800,
0x00000000,
0xb7f80002,
0x00051007,
0x1e612000,
0x00060010,
0x00000000,
0xfd000360,
0xfd000f60,
0x00000000,
0x9a958395,
0x00000000,
0x785fe39c,
0x54000009,
0x00070800,
0x00000000,
0x9a959395,
0x00000000,
0x54000009,
0x00070800,
0x00000000,
0x14000000,
0x0005000c,
0x00060011,
0x1e602020,
0x14000000,
0x00050010,
0x00000000,
0xd341fea0,
0x927f1400,
0x91000000,
0x000b0000,
0x78606ac1,
0xf1000021,
0x000b0000,
0x78206ac1,
0x54000003,
0x00050890,
0x00000000,
0xf87b7a60,
0x8b1b0e69,
0xeb1a001f,
0x54000000,
0x00050801,
0x00000000,
0xf81f8120,
0x14000000,
0x00070000,
0x00000000,
0x8b1c0aa8,
0xd1408115,
0xf81f8120,
0x00000000,
0x0006000b,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xd341fea0,
0x927f1400,
0x91000000,
0x000b0000,
0x78606ac1,
0xf1000021,
0x000b0000,
0x78206ac1,
0x54000003,
0x00050890,
0x00000000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xf84002c0,
0x000e0000,
0x52800001,
0xf87c781c,
0xb80002c1,
0x000e0000,
0xf840039b,
0x000e0000,
0xf80002d3,
0x000e0000,
0xf80002d7,
0x000e0000,
0xd10043ff,
0xd61f0360,
0x00000000,
0x8b1c0abc,
0xd1408395,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0xd341fea0,
0x927f1400,
0x91000000,
0x000b0000,
0x78606ac1,
0xf1000021,
0x000b0000,
0x78206ac1,
0x54000003,
0x00050892,
0x00000000,
0xf84002e0,
0x000e0000,
0x384002a9,
0x000e0000,
0xf84002b4,
0x000e0000,
0xeb00037f,
0x54000008,
0x00050820,
0x0006000c,
0xeb090f9f,
0x54000003,
0x00050803,
0x00000000,
0xd3507e1c,
0x14000000,
0x00070000,
0x00000000,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x00000000,
0x0006000d,
0xf83c6a7a,
0x9100239c,
0x14000000,
0x0005000c,
0x00000000,
0xd4200000,
0x00000000,
0xf84002e0,
0x000e0000,
0x92800008,
0x00090205,
0x8b1c026a,
0x8b08bc42,
0x8b1c037b,
0x91000388,
0x000b0000,
0xf8008542,
0xf84002b4,
0x000e0000,
0xeb00037f,
0xf8008548,
0x54000002,
0x00050820,
0xd100415c,
0x384002a9,
0x000e0000,
0xaa1303fb,
0xaa0a03f3,
0xb4000009,
0x00050802,
0x0006000b,
0xeb1c037f,
0x54000002,
0x00050803,
0xf9400368,
0xd1000529,
0xf800877a,
0xf8008548,
0xb5000009,
0x0005080b,
0x0006000c,
0xb84046b0,
0x8b300ec9,
0xd3483e1b,
0xf8400128,
0x000e0000,
0xd3507e1c,
0xd61f0100,
0x0006000d,
0xd1000529,
0xf800855a,
0xb4000009,
0x0005080c,
0x14000000,
0x0005000d,
0x00000000,
0xf8400043,
0x000e0000,
0x00000000,
0xf84002c3,
0x000e0000,
0x00000000,
0x8b1c0361,
0xf84002e0,
0x000e0000,
0x8b1c027c,
0xeb00003f,
0xa90072f3,
0x00098cef,
0x00000000,
0xf8400041,
0x000e0000,
0x00000000,
0x12800008,
0x00090205,
0xaa1703e0,
0x54000008,
0x0005081f,
0xb80002c8,
0x000e0000,
0xd63f0060,
0xa94026f3,
0x00098cef,
0xf80002d7,
0x000e0000,
0x937d7c1c,
0xb80002da,
0x000e0000,
0xf85f8275,
0xcb1c013b,
0x14000000,
0x00050016,
0x00000000,
0x00010000
};

#line 9 "vm_arm64.dasc"
//|.globals GLOB_
enum {
  GLOB_vm_returnp,
  GLOB_cont_dispatch,
  GLOB_vm_returnc,
  GLOB_vm_unwind_c_eh,
  GLOB_BC_RET_Z,
  GLOB_vm_return,
  GLOB_vm_leave_cp,
  GLOB_vm_leave_unw,
  GLOB_vm_unwind_c,
  GLOB_vm_unwind_ff,
  GLOB_vm_unwind_ff_eh,
  GLOB_vm_growstack_c,
  GLOB_vm_growstack_l,
  GLOB_vm_resume,
  GLOB_vm_pcall,
  GLOB_vm_call,
  GLOB_vm_call_dispatch,
  GLOB_vmeta_call,
  GLOB_vm_call_dispatch_f,
  GLOB_vm_cpcall,
  GLOB_cont_ffi_callback,
  GLOB_vm_call_tail,
  GLOB_cont_cat,
  GLOB_BC_CAT_Z,
  GLOB_cont_nop,
  GLOB_vmeta_tgets1,
  GLOB_vmeta_tgets,
  GLOB_vmeta_tgetb,
  GLOB_vmeta_tgetv,
  GLOB_vmeta_tgetr,
  GLOB_BC_TGETR_Z,
  GLOB_vmeta_tsets1,
  GLOB_vmeta_tsets,
  GLOB_vmeta_tsetb,
  GLOB_vmeta_tsetv,
  GLOB_vmeta_tsetr,
  GLOB_BC_TSETR_Z,
  GLOB_vmeta_comp,
  GLOB_vmeta_binop,
  GLOB_cont_ra,
  GLOB_cont_condt,
  GLOB_cont_condf,
  GLOB_vmeta_equal,
  GLOB_vmeta_equal_cd,
  GLOB_vmeta_istype,
  GLOB_vmeta_arith_vn,
  GLOB_vmeta_arith_nv,
  GLOB_vmeta_unm,
  GLOB_vmeta_arith_vv,
  GLOB_vmeta_len,
  GLOB_BC_LEN_Z,
  GLOB_vmeta_callt,
  GLOB_BC_CALLT2_Z,
  GLOB_vmeta_for,
  GLOB_ff_assert,
  GLOB_fff_fallback,
  GLOB_fff_res,
  GLOB_ff_type,
  GLOB_fff_restv,
  GLOB_ff_getmetatable,
  GLOB_ff_setmetatable,
  GLOB_ff_rawget,
  GLOB_ff_tonumber,
  GLOB_ff_tostring,
  GLOB_fff_gcstep,
  GLOB_ff_next,
  GLOB_fff_res1,
  GLOB_ff_pairs,
  GLOB_ff_ipairs_aux,
  GLOB_ff_ipairs,
  GLOB_ff_pcall,
  GLOB_ff_xpcall,
  GLOB_ff_coroutine_resume,
  GLOB_ff_coroutine_wrap_aux,
  GLOB_ff_coroutine_yield,
  GLOB_ff_math_floor,
  GLOB_fff_resn,
  GLOB_ff_math_ceil,
  GLOB_ff_math_abs,
  GLOB_ff_math_sqrt,
  GLOB_ff_math_log,
  GLOB_ff_math_log10,
  GLOB_ff_math_exp,
  GLOB_ff_math_sin,
  GLOB_ff_math_cos,
  GLOB_ff_math_tan,
  GLOB_ff_math_asin,
  GLOB_ff_math_acos,
  GLOB_ff_math_atan,
  GLOB_ff_math_sinh,
  GLOB_ff_math_cosh,
  GLOB_ff_math_tanh,
  GLOB_ff_math_pow,
  GLOB_ff_math_atan2,
  GLOB_ff_math_fmod,
  GLOB_ff_math_ldexp,
  GLOB_ff_math_frexp,
  GLOB_ff_math_modf,
  GLOB_ff_math_min,
  GLOB_ff_math_max,
  GLOB_ff_string_byte,
  GLOB_ff_string_char,
  GLOB_fff_newstr,
  GLOB_fff_resstr,
  GLOB_ff_string_sub,
  GLOB_ff_string_reverse,
  GLOB_ff_string_lower,
  GLOB_ff_string_upper,
  GLOB_vm_tobit_fb,
  GLOB_ff_bit_band,
  GLOB_ff_bit_bor,
  GLOB_ff_bit_bxor,
  GLOB_ff_bit_tobit,
  GLOB_ff_bit_bswap,
  GLOB_ff_bit_bnot,
  GLOB_ff_bit_lshift,
  GLOB_ff_bit_rshift,
  GLOB_ff_bit_arshift,
  GLOB_ff_bit_rol,
  GLOB_ff_bit_ror,
  GLOB_vm_record,
  GLOB_vm_rethook,
  GLOB_vm_inshook,
  GLOB_cont_hook,
  GLOB_vm_hotloop,
  GLOB_vm_callhook,
  GLOB_vm_hotcall,
  GLOB_cont_stitch,
  GLOB_vm_profhook,
  GLOB_vm_exit_handler,
  GLOB_vm_exit_interp,
  GLOB_vm_modi,
  GLOB_vm_ffi_callback,
  GLOB_vm_ffi_call,
  GLOB_BC_ISEQN_Z,
  GLOB_BC_ISNEN_Z,
  GLOB_BC_ISEQV_Z,
  GLOB_BC_TGETS_Z,
  GLOB_BC_TSETS_Z,
  GLOB_BC_CALL_Z,
  GLOB_BC_CALLT1_Z,
  GLOB_BC_RETM_Z,
  GLOB_BC_RETV2_Z,
  GLOB_BC_RETV1_Z,
  GLOB__MAX
};
#line 10 "vm_arm64.dasc"
//|.globalnames globnames
static const char *const globnames[] = {
  "vm_returnp",
  "cont_dispatch",
  "vm_returnc",
  "vm_unwind_c_eh",
  "BC_RET_Z",
  "vm_return",
  "vm_leave_cp",
  "vm_leave_unw",
  "vm_unwind_c",
  "vm_unwind_ff",
  "vm_unwind_ff_eh",
  "vm_growstack_c",
  "vm_growstack_l",
  "vm_resume",
  "vm_pcall",
  "vm_call",
  "vm_call_dispatch",
  "vmeta_call",
  "vm_call_dispatch_f",
  "vm_cpcall",
  "cont_ffi_callback",
  "vm_call_tail",
  "cont_cat",
  "BC_CAT_Z",
  "cont_nop",
  "vmeta_tgets1",
  "vmeta_tgets",
  "vmeta_tgetb",
  "vmeta_tgetv",
  "vmeta_tgetr",
  "BC_TGETR_Z",
  "vmeta_tsets1",
  "vmeta_tsets",
  "vmeta_tsetb",
  "vmeta_tsetv",
  "vmeta_tsetr",
  "BC_TSETR_Z",
  "vmeta_comp",
  "vmeta_binop",
  "cont_ra",
  "cont_condt",
  "cont_condf",
  "vmeta_equal",
  "vmeta_equal_cd",
  "vmeta_istype",
  "vmeta_arith_vn",
  "vmeta_arith_nv",
  "vmeta_unm",
  "vmeta_arith_vv",
  "vmeta_len",
  "BC_LEN_Z",
  "vmeta_callt",
  "BC_CALLT2_Z",
  "vmeta_for",
  "ff_assert",
  "fff_fallback",
  "fff_res",
  "ff_type",
  "fff_restv",
  "ff_getmetatable",
  "ff_setmetatable",
  "ff_rawget",
  "ff_tonumber",
  "ff_tostring",
  "fff_gcstep",
  "ff_next",
  "fff_res1",
  "ff_pairs",
  "ff_ipairs_aux",
  "ff_ipairs",
  "ff_pcall",
  "ff_xpcall",
  "ff_coroutine_resume",
  "ff_coroutine_wrap_aux",
  "ff_coroutine_yield",
  "ff_math_floor",
  "fff_resn",
  "ff_math_ceil",
  "ff_math_abs",
  "ff_math_sqrt",
  "ff_math_log",
  "ff_math_log10",
  "ff_math_exp",
  "ff_math_sin",
  "ff_math_cos",
  "ff_math_tan",
  "ff_math_asin",
  "ff_math_acos",
  "ff_math_atan",
  "ff_math_sinh",
  "ff_math_cosh",
  "ff_math_tanh",
  "ff_math_pow",
  "ff_math_atan2",
  "ff_math_fmod",
  "ff_math_ldexp",
  "ff_math_frexp",
  "ff_math_modf",
  "ff_math_min",
  "ff_math_max",
  "ff_string_byte",
  "ff_string_char",
  "fff_newstr",
  "fff_resstr",
  "ff_string_sub",
  "ff_string_reverse",
  "ff_string_lower",
  "ff_string_upper",
  "vm_tobit_fb",
  "ff_bit_band",
  "ff_bit_bor",
  "ff_bit_bxor",
  "ff_bit_tobit",
  "ff_bit_bswap",
  "ff_bit_bnot",
  "ff_bit_lshift",
  "ff_bit_rshift",
  "ff_bit_arshift",
  "ff_bit_rol",
  "ff_bit_ror",
  "vm_record",
  "vm_rethook",
  "vm_inshook",
  "cont_hook",
  "vm_hotloop",
  "vm_callhook",
  "vm_hotcall",
  "cont_stitch",
  "vm_profhook",
  "vm_exit_handler",
  "vm_exit_interp",
  "vm_modi",
  "vm_ffi_callback",
  "vm_ffi_call",
  "BC_ISEQN_Z",
  "BC_ISNEN_Z",
  "BC_ISEQV_Z",
  "BC_TGETS_Z",
  "BC_TSETS_Z",
  "BC_CALL_Z",
  "BC_CALLT1_Z",
  "BC_RETM_Z",
  "BC_RETV2_Z",
  "BC_RETV1_Z",
  (const char *)0
};
#line 11 "vm_arm64.dasc"
//|.externnames extnames
static const char *const extnames[] = {
  "lj_state_growstack",
  "lj_meta_tget",
  "lj_tab_getinth",
  "lj_meta_tset",
  "lj_tab_setinth",
  "lj_meta_comp",
  "lj_meta_equal",
  "lj_meta_equal_cd",
  "lj_meta_istype",
  "lj_meta_arith",
  "lj_meta_len",
  "lj_meta_call",
  "lj_meta_for",
  "lj_tab_get",
  "lj_strfmt_number",
  "lj_tab_next",
  "lj_ffh_coroutine_wrap_err",
  "log",
  "log10",
  "exp",
  "sin",
  "cos",
  "tan",
  "asin",
  "acos",
  "atan",
  "sinh",
  "cosh",
  "tanh",
  "pow",
  "atan2",
  "fmod",
  "ldexp",
  "frexp",
  "modf",
  "lj_str_new",
  "lj_buf_putstr_reverse",
  "lj_buf_tostr",
  "lj_buf_putstr_lower",
  "lj_buf_putstr_upper",
  "lj_gc_step",
  "lj_dispatch_ins",
  "lj_trace_hot",
  "lj_dispatch_call",
  "lj_dispatch_stitch",
  "lj_dispatch_profile",
  "lj_trace_exit",
  "lj_err_throw",
  "lj_ccallback_enter",
  "lj_ccallback_leave",
  "lj_tab_len",
  "lj_meta_cat",
  "lj_gc_barrieruv",
  "lj_func_closeuv",
  "lj_func_newL_gc",
  "lj_tab_new",
  "lj_tab_dup",
  "lj_gc_step_fixtop",
  "lj_tab_newkey",
  "lj_tab_reasize",
  (const char *)0
};
#line 12 "vm_arm64.dasc"
//|
//|// Note: The ragged indentation of the instructions is intentional.
//|//       The starting columns indicate data dependencies.
//|
//|//-----------------------------------------------------------------------
//|
//|// ARM64 registers and the AAPCS64 ABI 1.0 at a glance:
//|//
//|// x0-x17 temp, x19-x28 callee-saved, x29 fp, x30 lr
//|// x18 is reserved on most platforms. Don't use it, save it or restore it.
//|// x31 doesn't exist. Register number 31 either means xzr/wzr (zero) or sp,
//|// depending on the instruction.
//|// v0-v7 temp, v8-v15 callee-saved (only d8-d15 preserved), v16-v31 temp
//|//
//|// x0-x7/v0-v7 hold parameters and results.
//|
//|// Fixed register assignments for the interpreter.
//|
//|// The following must be C callee-save.
//|.define BASE,		x19	// Base of current Lua stack frame.
//|.define KBASE,		x20	// Constants of current Lua function.
//|.define PC,		x21	// Next PC.
//|.define GLREG,		x22	// Global state.
//|.define LREG,		x23	// Register holding lua_State (also in SAVE_L).
//|.define TISNUM,	x24	// Constant LJ_TISNUM << 47.
//|.define TISNUMhi,	x25	// Constant LJ_TISNUM << 15.
//|.define TISNIL,	x26	// Constant -1LL.
//|.define fp,		x29	// Yes, we have to maintain a frame pointer.
//|
//|.define ST_INTERP,	w26	// Constant -1.
//|
//|// The following temporaries are not saved across C calls, except for RA/RC.
//|.define RA,		x27
//|.define RC,		x28
//|.define RB,		x17
//|.define RAw,		w27
//|.define RCw,		w28
//|.define RBw,		w17
//|.define INS,		x16
//|.define INSw,		w16
//|.define ITYPE,		x15
//|.define TMP0,		x8
//|.define TMP1,		x9
//|.define TMP2,		x10
//|.define TMP3,		x11
//|.define TMP0w,		w8
//|.define TMP1w,		w9
//|.define TMP2w,		w10
//|.define TMP3w,		w11
//|
//|// Calling conventions. Also used as temporaries.
//|.define CARG1,		x0
//|.define CARG2,		x1
//|.define CARG3,		x2
//|.define CARG4,		x3
//|.define CARG5,		x4
//|.define CARG1w,	w0
//|.define CARG2w,	w1
//|.define CARG3w,	w2
//|.define CARG4w,	w3
//|.define CARG5w,	w4
//|
//|.define FARG1,		d0
//|.define FARG2,		d1
//|
//|.define CRET1,		x0
//|.define CRET1w,	w0
//|
//|// Stack layout while in interpreter. Must match with lj_frame.h.
//|
//|.define CFRAME_SPACE,	208
//|//----- 16 byte aligned, <-- sp entering interpreter
//|// Unused		[sp, #204]	// 32 bit values
//|.define SAVE_NRES,	[sp, #200]
//|.define SAVE_ERRF,	[sp, #196]
//|.define SAVE_MULTRES,	[sp, #192]
//|.define TMPD,		[sp, #184]	// 64 bit values
//|.define SAVE_L,	[sp, #176]
//|.define SAVE_PC,	[sp, #168]
//|.define SAVE_CFRAME,	[sp, #160]
//|.define SAVE_FPR_,	96		// 96+8*8: 64 bit FPR saves
//|.define SAVE_GPR_,	16		// 16+10*8: 64 bit GPR saves
//|.define SAVE_LR,	[sp, #8]
//|.define SAVE_FP,	[sp]
//|//----- 16 byte aligned, <-- sp while in interpreter.
//|
//|.define TMPDofs,	#184
//|
//|.macro save_, gpr1, gpr2, fpr1, fpr2
//|  stp d..fpr1, d..fpr2, [sp, # SAVE_FPR_+(fpr1-8)*8]
//|  stp x..gpr1, x..gpr2, [sp, # SAVE_GPR_+(gpr1-19)*8]
//|.endmacro
//|.macro rest_, gpr1, gpr2, fpr1, fpr2
//|  ldp d..fpr1, d..fpr2, [sp, # SAVE_FPR_+(fpr1-8)*8]
//|  ldp x..gpr1, x..gpr2, [sp, # SAVE_GPR_+(gpr1-19)*8]
//|.endmacro
//|
//|.macro saveregs
//|  stp fp, lr, [sp, #-CFRAME_SPACE]!
//|  add fp, sp, #0
//|  stp x19, x20, [sp, # SAVE_GPR_]
//|  save_ 21, 22, 8, 9
//|  save_ 23, 24, 10, 11
//|  save_ 25, 26, 12, 13
//|  save_ 27, 28, 14, 15
//|.endmacro
//|.macro restoreregs
//|  ldp x19, x20, [sp, # SAVE_GPR_]
//|  rest_ 21, 22, 8, 9
//|  rest_ 23, 24, 10, 11
//|  rest_ 25, 26, 12, 13
//|  rest_ 27, 28, 14, 15
//|  ldp fp, lr, [sp], # CFRAME_SPACE
//|.endmacro
//|
//|// Type definitions. Some of these are only used for documentation.
//|.type L,		lua_State,	LREG
#define Dt1(_V) (int)(ptrdiff_t)&(((lua_State *)0)_V)
#line 129 "vm_arm64.dasc"
//|.type GL,		global_State,	GLREG
#define Dt2(_V) (int)(ptrdiff_t)&(((global_State *)0)_V)
#line 130 "vm_arm64.dasc"
//|.type TVALUE,		TValue
#define Dt3(_V) (int)(ptrdiff_t)&(((TValue *)0)_V)
#line 131 "vm_arm64.dasc"
//|.type GCOBJ,		GCobj
#define Dt4(_V) (int)(ptrdiff_t)&(((GCobj *)0)_V)
#line 132 "vm_arm64.dasc"
//|.type STR,		GCstr
#define Dt5(_V) (int)(ptrdiff_t)&(((GCstr *)0)_V)
#line 133 "vm_arm64.dasc"
//|.type TAB,		GCtab
#define Dt6(_V) (int)(ptrdiff_t)&(((GCtab *)0)_V)
#line 134 "vm_arm64.dasc"
//|.type LFUNC,		GCfuncL
#define Dt7(_V) (int)(ptrdiff_t)&(((GCfuncL *)0)_V)
#line 135 "vm_arm64.dasc"
//|.type CFUNC,		GCfuncC
#define Dt8(_V) (int)(ptrdiff_t)&(((GCfuncC *)0)_V)
#line 136 "vm_arm64.dasc"
//|.type PROTO,		GCproto
#define Dt9(_V) (int)(ptrdiff_t)&(((GCproto *)0)_V)
#line 137 "vm_arm64.dasc"
//|.type UPVAL,		GCupval
#define DtA(_V) (int)(ptrdiff_t)&(((GCupval *)0)_V)
#line 138 "vm_arm64.dasc"
//|.type NODE,		Node
#define DtB(_V) (int)(ptrdiff_t)&(((Node *)0)_V)
#line 139 "vm_arm64.dasc"
//|.type NARGS8,		int
#define DtC(_V) (int)(ptrdiff_t)&(((int *)0)_V)
#line 140 "vm_arm64.dasc"
//|.type TRACE,		GCtrace
#define DtD(_V) (int)(ptrdiff_t)&(((GCtrace *)0)_V)
#line 141 "vm_arm64.dasc"
//|.type SBUF,		SBuf
#define DtE(_V) (int)(ptrdiff_t)&(((SBuf *)0)_V)
#line 142 "vm_arm64.dasc"
//|
//|//-----------------------------------------------------------------------
//|
//|// Trap for not-yet-implemented parts.
//|.macro NYI; brk; .endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Access to frame relative to BASE.
//|.define FRAME_FUNC,	#-16
//|.define FRAME_PC,	#-8
//|
//|// Endian-specific defines.
//|.if ENDIAN_LE
//|.define LO,		0
//|.define OFS_RD,	2
//|.define OFS_RB,	3
//|.define OFS_RA,	1
//|.define OFS_OP,	0
//|.else
//|.define LO,		4
//|.define OFS_RD,	0
//|.define OFS_RB,	0
//|.define OFS_RA,	2
//|.define OFS_OP,	3
//|.endif
//|
//|.macro decode_RA, dst, ins; ubfx dst, ins, #8, #8; .endmacro
//|.macro decode_RB, dst, ins; ubfx dst, ins, #24, #8; .endmacro
//|.macro decode_RC, dst, ins; ubfx dst, ins, #16, #8; .endmacro
//|.macro decode_RD, dst, ins; ubfx dst, ins, #16, #16; .endmacro
//|.macro decode_RC8RD, dst, src; ubfiz dst, src, #3, #8; .endmacro
//|
//|// Instruction decode+dispatch.
//|.macro ins_NEXT
//|  ldr INSw, [PC], #4
//|  add TMP1, GL, INS, uxtb #3
//|   decode_RA RA, INS
//|  ldr TMP0, [TMP1, #GG_G2DISP]
//|   decode_RD RC, INS
//|  br TMP0
//|.endmacro
//|
//|// Instruction footer.
//|.if 1
//|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
//|  .define ins_next, ins_NEXT
//|  .define ins_next_, ins_NEXT
//|.else
//|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
//|  // Affects only certain kinds of benchmarks (and only with -j off).
//|  .macro ins_next
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next_
//|  ->ins_next:
//|    ins_NEXT
//|  .endmacro
//|.endif
//|
//|// Call decode and dispatch.
//|.macro ins_callt
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
//|  ldr PC, LFUNC:CARG3->pc
//|  ldr INSw, [PC], #4
//|  add TMP1, GL, INS, uxtb #3
//|   decode_RA RA, INS
//|  ldr TMP0, [TMP1, #GG_G2DISP]
//|   add RA, BASE, RA, lsl #3
//|  br TMP0
//|.endmacro
//|
//|.macro ins_call
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
//|  str PC, [BASE, FRAME_PC]
//|  ins_callt
//|.endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Macros to check the TValue type and extract the GCobj. Branch on failure.
//|.macro checktp, reg, tp, target
//|  asr ITYPE, reg, #47
//|  cmn ITYPE, #-tp
//|   and reg, reg, #LJ_GCVMASK
//|  bne target
//|.endmacro
//|.macro checktp, dst, reg, tp, target
//|  asr ITYPE, reg, #47
//|  cmn ITYPE, #-tp
//|   and dst, reg, #LJ_GCVMASK
//|  bne target
//|.endmacro
//|.macro checkstr, reg, target; checktp reg, LJ_TSTR, target; .endmacro
//|.macro checktab, reg, target; checktp reg, LJ_TTAB, target; .endmacro
//|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC, target; .endmacro
//|.macro checkint, reg, target
//|  cmp TISNUMhi, reg, lsr #32
//|  bne target
//|.endmacro
//|.macro checknum, reg, target
//|  cmp TISNUMhi, reg, lsr #32
//|  bls target
//|.endmacro
//|.macro checknumber, reg, target
//|  cmp TISNUMhi, reg, lsr #32
//|  blo target
//|.endmacro
//|
//|.macro mov_false, reg; movn reg, #0x8000, lsl #32; .endmacro
//|.macro mov_true, reg; movn reg, #0x0001, lsl #48; .endmacro
//|
#define GL_J(field)	(GG_G2J + (int)offsetof(jit_State, field))
//|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
//|
//|.macro hotcheck, delta
//|  lsr CARG1, PC, #1
//|  and CARG1, CARG1, #126
//|  add CARG1, CARG1, #GG_G2DISP+GG_DISP2HOT
//|  ldrh CARG2w, [GL, CARG1]
//|  subs CARG2, CARG2, #delta
//|  strh CARG2w, [GL, CARG1]
//|.endmacro
//|
//|.macro hotloop
//|  hotcheck HOTCOUNT_LOOP
//|  blo ->vm_hotloop
//|.endmacro
//|
//|.macro hotcall
//|  hotcheck HOTCOUNT_CALL
//|  blo ->vm_hotcall
//|.endmacro
//|
//|// Set current VM state.
//|.macro mv_vmstate, reg, st; movn reg, #LJ_VMST_..st; .endmacro
//|.macro st_vmstate, reg; str reg, GL->vmstate; .endmacro
//|
//|// Move table write barrier back. Overwrites mark and tmp.
//|.macro barrierback, tab, mark, tmp
//|  ldr tmp, GL->gc.grayagain
//|   and mark, mark, #~LJ_GC_BLACK	// black2gray(tab)
//|  str tab, GL->gc.grayagain
//|   strb mark, tab->marked
//|  str tmp, tab->gclist
//|.endmacro
//|
//|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM64 target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  //|.code_sub
  dasm_put(Dst, 0);
#line 301 "vm_arm64.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Return handling ----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_returnp:
  //|  // See vm_return. Also: RB = previous base.
  //|  tbz PC, #2, ->cont_dispatch	// (PC & FRAME_P) == 0?
  //|
  //|  // Return from pcall or xpcall fast func.
  //|  ldr PC, [RB, FRAME_PC]		// Fetch PC of previous frame.
  //|   mov_true TMP0
  //|  mov BASE, RB
  //|  // Prepending may overwrite the pcall frame, so do it at the end.
  //|   str TMP0, [RA, #-8]!		// Prepend true to results.
  //|
  //|->vm_returnc:
  //|  adds RC, RC, #8			// RC = (nresults+1)*8.
  //|  mov CRET1, #LUA_YIELD
  //|  beq ->vm_unwind_c_eh
  //|  str RCw, SAVE_MULTRES
  //|  ands CARG1, PC, #FRAME_TYPE
  //|  beq ->BC_RET_Z			// Handle regular return to Lua.
  //|
  //|->vm_return:
  //|  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  //|  // CARG1 = PC & FRAME_TYPE
  //|  and RB, PC, #~FRAME_TYPEP
  //|   cmp CARG1, #FRAME_C
  //|  sub RB, BASE, RB			// RB = previous base.
  //|   bne ->vm_returnp
  //|
  //|  str RB, L->base
  //|   ldrsw CARG2, SAVE_NRES		// CARG2 = nresults+1.
  //|    mv_vmstate TMP0w, C
  //|   sub BASE, BASE, #16
  //|  subs TMP2, RC, #8
  //|    st_vmstate TMP0w
  //|  beq >2
  //|1:
  //|  subs TMP2, TMP2, #8
  //|   ldr TMP0, [RA], #8
  //|   str TMP0, [BASE], #8
  //|  bne <1
  //|2:
  //|  cmp RC, CARG2, lsl #3		// More/less results wanted?
  //|  bne >6
  //|3:
  //|  str BASE, L->top			// Store new top.
  //|
  //|->vm_leave_cp:
  //|  ldr RC, SAVE_CFRAME		// Restore previous C frame.
  dasm_put(Dst, 1, LUA_YIELD, (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), (unsigned int)(~FRAME_TYPEP), (unsigned int)((unsigned long long)(~FRAME_TYPEP)>>32), FRAME_C, Dt1(->base), LJ_VMST_C, Dt2(->vmstate), Dt1(->top));
#line 353 "vm_arm64.dasc"
  //|   mov CRET1, #0			// Ok return status for vm_pcall.
  //|  str RC, L->cframe
  //|
  //|->vm_leave_unw:
  //|  restoreregs
  //|  ret
  //|
  //|6:
  //|  bgt >7				// Less results wanted?
  //|  // More results wanted. Check stack size and fill up results with nil.
  //|  ldr CARG3, L->maxstack
  //|  cmp BASE, CARG3
  //|  bhs >8
  //|   str TISNIL, [BASE], #8
  //|  add RC, RC, #8
  //|  b <2
  //|
  //|7:  // Less results wanted.
  //|  cbz CARG2, <3			// LUA_MULTRET+1 case?
  //|  sub CARG1, RC, CARG2, lsl #3
  //|  sub BASE, BASE, CARG1		// Shrink top.
  //|  b <3
  //|
  //|8:  // Corner case: need to grow stack for filling up results.
  //|  // This can happen if:
  //|  // - A C function grows the stack (a lot).
  //|  // - The GC shrinks the stack in between.
  //|  // - A return back from a lua_call() with (high) nresults adjustment.
  //|  str BASE, L->top			// Save current top held in BASE (yes).
  //|  mov CARG1, L
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->top			// Need the (realloced) L->top in BASE.
  //|  ldrsw CARG2, SAVE_NRES
  //|  b <2
  //|
  //|->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  //|  // (void *cframe, int errcode)
  //|  mov sp, CARG1
  //|  mov CRET1, CARG2
  //|->vm_unwind_c_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|   mv_vmstate TMP0w, C
  //|  ldr GL, L->glref
  //|   st_vmstate TMP0w
  //|  b ->vm_leave_unw
  //|
  //|->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  //|  // (void *cframe)
  //|  and sp, CARG1, #CFRAME_RAWMASK
  dasm_put(Dst, 53, Dt1(->cframe), Dt1(->maxstack), Dt1(->top), Dt1(->top), LJ_VMST_C, Dt1(->glref), Dt2(->vmstate));
#line 402 "vm_arm64.dasc"
  //|->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
  //|    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
  //|    movn TISNIL, #0
  //|    mov RC, #16			// 2 results: false + error message.
  //|  ldr BASE, L->base
  //|   ldr GL, L->glref			// Setup pointer to global state.
  //|    mov_false TMP0
  //|  sub RA, BASE, #8			// Results start at BASE-8.
  //|  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
  //|    str TMP0, [BASE, #-8]		// Prepend false to error message.
  //|   st_vmstate ST_INTERP
  //|  b ->vm_returnc
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Grow stack for calls -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_growstack_c:			// Grow stack for C function.
  //|  // CARG1 = L
  //|  mov CARG2, #LUA_MINSTACK
  //|  b >2
  //|
  //|->vm_growstack_l:			// Grow stack for Lua function.
  //|  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  //|  add RC, BASE, RC
  //|   sub RA, RA, BASE
  //|    mov CARG1, L
  //|  stp BASE, RC, L->base
  //|   add PC, PC, #4			// Must point after first instruction.
  //|   lsr CARG2, RA, #3
  //|2:
  //|  // L->base = new base, L->top = top
  //|  str PC, SAVE_PC
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldp BASE, RC, L->base
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   sub NARGS8:RC, RC, BASE
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  //|  ins_callt				// Just retry the call.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Entry points into the assembler VM ---------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_resume:				// Setup C frame and resume thread.
  //|  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  //|  saveregs
  //|  mov L, CARG1
  //|    ldr GL, L->glref			// Setup pointer to global state.
  //|  mov BASE, CARG2
  //|   str L, SAVE_L
  //|  mov PC, #FRAME_CP
  //|   str wzr, SAVE_NRES
  dasm_put(Dst, 114, (unsigned int)(CFRAME_RAWMASK), (unsigned int)((unsigned long long)(CFRAME_RAWMASK)>>32), (LJ_TISNUM>>1)&0xffff, (LJ_TISNUM>>1)&0xffff, Dt1(->base), Dt1(->glref), Dt2(->vmstate), LUA_MINSTACK, Dt1(->base), Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP, Dt1(->glref), FRAME_CP);
#line 458 "vm_arm64.dasc"
  //|    add TMP0, sp, #CFRAME_RESUME
  //|  ldrb TMP1w, L->status
  //|   str wzr, SAVE_ERRF
  //|   str L, SAVE_PC			// Any value outside of bytecode is ok.
  //|   str xzr, SAVE_CFRAME
  //|    str TMP0, L->cframe
  //|  cbz TMP1w, >3
  //|
  //|  // Resume after yield (like a return).
  //|  str L, GL->cur_L
  //|  mov RA, BASE
  //|   ldp BASE, CARG1, L->base
  //|    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
  //|    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
  //|  ldr PC, [BASE, FRAME_PC]
  //|     strb wzr, L->status
  //|    movn TISNIL, #0
  //|   sub RC, CARG1, BASE
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   add RC, RC, #8
  //|     st_vmstate ST_INTERP
  //|   str RCw, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|->vm_pcall:				// Setup protected C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  //|  saveregs
  //|  mov PC, #FRAME_CP
  //|  str CARG4w, SAVE_ERRF
  //|  b >1
  //|
  //|->vm_call:				// Setup C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1)
  //|  saveregs
  //|  mov PC, #FRAME_C
  //|
  //|1:  // Entry point for vm_pcall above (PC = ftype).
  //|  ldr RC, L:CARG1->cframe
  //|   str CARG3w, SAVE_NRES
  //|    mov L, CARG1
  //|   str CARG1, SAVE_L
  //|    ldr GL, L->glref			// Setup pointer to global state.
  //|     mov BASE, CARG2
  //|   str CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  //|  str RC, SAVE_CFRAME
  //|  str fp, L->cframe			// Add our C frame to cframe chain.
  //|
  //|3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  //|  str L, GL->cur_L
  dasm_put(Dst, 188, CFRAME_RESUME, Dt1(->status), Dt1(->cframe), Dt2(->cur_L), Dt1(->base), (LJ_TISNUM>>1)&0xffff, (LJ_TISNUM>>1)&0xffff, Dt1(->status), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), Dt2(->vmstate), FRAME_CP, FRAME_C, Dt1(->cframe), Dt1(->glref), Dt1(->cframe));
#line 508 "vm_arm64.dasc"
  //|  ldp RB, CARG1, L->base		// RB = old base (for vmeta_call).
  //|    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
  //|    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
  //|  add PC, PC, BASE
  //|    movn TISNIL, #0
  //|  sub PC, PC, RB			// PC = frame delta + frame type
  //|   sub NARGS8:RC, CARG1, BASE
  //|    st_vmstate ST_INTERP
  //|
  //|->vm_call_dispatch:
  //|  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC
  //|  ldr CARG3, [BASE, FRAME_FUNC]
  //|  checkfunc CARG3, ->vmeta_call
  //|
  //|->vm_call_dispatch_f:
  //|  ins_call
  //|  // BASE = new base, CARG3 = func, RC = nargs*8, PC = caller PC
  //|
  //|->vm_cpcall:				// Setup protected C frame, call C.
  //|  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  //|  saveregs
  //|  mov L, CARG1
  //|   ldr RA, L:CARG1->stack
  //|  str CARG1, SAVE_L
  //|    ldr GL, L->glref			// Setup pointer to global state.
  //|   ldr RB, L->top
  //|  str CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  //|  ldr RC, L->cframe
  //|   sub RA, RA, RB			// Compute -savestack(L, L->top).
  //|   str RAw, SAVE_NRES		// Neg. delta means cframe w/o frame.
  //|  str wzr, SAVE_ERRF			// No error function.
  //|  str RC, SAVE_CFRAME
  //|  str fp, L->cframe			// Add our C frame to cframe chain.
  //|    str L, GL->cur_L
  //|  blr CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  //|  mov BASE, CRET1
  //|   mov PC, #FRAME_CP
  //|  cbnz BASE, <3			// Else continue with the call.
  //|  b ->vm_leave_cp			// No base? Just remove C frame.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Metamethod handling ------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-- Continuation dispatch ----------------------------------------------
  //|
  //|->cont_dispatch:
  //|  // BASE = meta base, RA = resultptr, RC = (nresults+1)*8
  //|  ldr LFUNC:CARG3, [RB, FRAME_FUNC]
  dasm_put(Dst, 270, Dt2(->cur_L), Dt1(->base), (LJ_TISNUM>>1)&0xffff, (LJ_TISNUM>>1)&0xffff, Dt2(->vmstate), -LJ_TFUNC, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP, Dt1(->stack), Dt1(->glref), Dt1(->top), Dt1(->cframe), Dt1(->cframe), Dt2(->cur_L), FRAME_CP);
#line 557 "vm_arm64.dasc"
  //|    ldr CARG1, [BASE, #-32]		// Get continuation.
  //|   mov CARG4, BASE
  //|   mov BASE, RB			// Restore caller BASE.
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|.if FFI
  //|    cmp CARG1, #1
  //|.endif
  //|   ldr PC, [CARG4, #-24]		// Restore PC from [cont|PC].
  //|  ldr CARG3, LFUNC:CARG3->pc
  //|    add TMP0, RA, RC
  //|    str TISNIL, [TMP0, #-8]		// Ensure one valid arg.
  //|.if FFI
  //|    bls >1
  //|.endif
  //|  ldr KBASE, [CARG3, #PC2PROTO(k)]
  //|  // BASE = base, RA = resultptr, CARG4 = meta base
  //|    br CARG1
  //|
  //|.if FFI
  //|1:
  //|  beq ->cont_ffi_callback		// cont = 1: return from FFI callback.
  //|  // cont = 0: tailcall from C function.
  //|   sub CARG4, CARG4, #32
  //|   sub RC, CARG4, BASE
  //|  b ->vm_call_tail
  //|.endif
  //|
  //|->cont_cat:				// RA = resultptr, CARG4 = meta base
  //|  ldr INSw, [PC, #-4]
  //|   sub CARG2, CARG4, #32
  //|   ldr TMP0, [RA]
  //|     str BASE, L->base
  //|  decode_RB RB, INS
  //|   decode_RA RA, INS
  //|  add TMP1, BASE, RB, lsl #3
  //|  subs TMP1, CARG2, TMP1
  //|  beq >1
  //|   str TMP0, [CARG2]
  //|  lsr CARG3, TMP1, #3
  //|  b ->BC_CAT_Z
  //|
  //|1:
  //|   str TMP0, [BASE, RA, lsl #3]
  //|  b ->cont_nop
  //|
  //|//-- Table indexing metamethods -----------------------------------------
  //|
  //|->vmeta_tgets1:
  //|  movn CARG4, #~LJ_TSTR
  //|   add CARG2, BASE, RB, lsl #3
  //|  add CARG4, STR:RC, CARG4, lsl #47
  //|  b >2
  //|
  //|->vmeta_tgets:
  //|  movk CARG2, #(LJ_TTAB>>1)&0xffff, lsl #48
  //|  str CARG2, GL->tmptv
  //|  add CARG2, GL, #offsetof(global_State, tmptv)
  //|2:
  //|   add CARG3, sp, TMPDofs
  //|  str CARG4, TMPD
  //|  b >1
  //|
  //|->vmeta_tgetb:			// RB = table, RC = index
  //|  add RC, RC, TISNUM
  dasm_put(Dst, 345, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), PC2PROTO(k), Dt1(->base), ~LJ_TSTR, (LJ_TTAB>>1)&0xffff, Dt2(->tmptv), offsetof(global_State, tmptv));
#line 621 "vm_arm64.dasc"
  //|   add CARG2, BASE, RB, lsl #3
  //|   add CARG3, sp, TMPDofs
  //|  str RC, TMPD
  //|  b >1
  //|
  //|->vmeta_tgetv:			// RB = table, RC = key
  //|  add CARG2, BASE, RB, lsl #3
  //|   add CARG3, BASE, RC, lsl #3
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  cbz CRET1, >3
  //|  ldr TMP0, [CRET1]
  //|  str TMP0, [BASE, RA, lsl #3]
  //|  ins_next
  //|
  //|3:  // Call __index metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k
  //|   sub TMP1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #16		// 2 args for func(t, k).
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|    str PC, [BASE, #-24]		// [cont|PC]
  //|   sub PC, BASE, TMP1
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  b ->vm_call_dispatch_f
  //|
  //|->vmeta_tgetr:
  //|  sxtw CARG2, TMP1w
  //|  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  //|  // Returns cTValue * or NULL.
  //|  mov TMP0, TISNIL
  //|  cbz CRET1, ->BC_TGETR_Z
  //|  ldr TMP0, [CRET1]
  //|  b ->BC_TGETR_Z
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->vmeta_tsets1:
  //|  movn CARG4, #~LJ_TSTR
  //|   add CARG2, BASE, RB, lsl #3
  //|  add CARG4, STR:RC, CARG4, lsl #47
  //|  b >2
  //|
  //|->vmeta_tsets:
  //|  movk CARG2, #(LJ_TTAB>>1)&0xffff, lsl #48
  //|  str CARG2, GL->tmptv
  //|  add CARG2, GL, #offsetof(global_State, tmptv)
  dasm_put(Dst, 410, Dt1(->base), GG_G2DISP, FRAME_CONT, Dt1(->top), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), ~LJ_TSTR, (LJ_TTAB>>1)&0xffff, Dt2(->tmptv));
#line 672 "vm_arm64.dasc"
  //|2:
  //|   add CARG3, sp, TMPDofs
  //|  str CARG4, TMPD
  //|  b >1
  //|
  //|->vmeta_tsetb:			// RB = table, RC = index
  //|  add RC, RC, TISNUM
  //|   add CARG2, BASE, RB, lsl #3
  //|   add CARG3, sp, TMPDofs
  //|  str RC, TMPD
  //|  b >1
  //|
  //|->vmeta_tsetv:
  //|  add CARG2, BASE, RB, lsl #3
  //|   add CARG3, BASE, RC, lsl #3
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|   ldr TMP0, [BASE, RA, lsl #3]
  //|  cbz CRET1, >3
  //|  // NOBARRIER: lj_meta_tset ensures the table is not black.
  //|   str TMP0, [CRET1]
  //|  ins_next
  //|
  //|3:  // Call __newindex metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  //|   sub TMP1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #24		// 3 args for func(t, k, v).
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   str TMP0, [BASE, #16]		// Copy value to third argument.
  //|    str PC, [BASE, #-24]		// [cont|PC]
  //|   sub PC, BASE, TMP1
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  b ->vm_call_dispatch_f
  //|
  //|->vmeta_tsetr:
  //|  sxtw CARG3, TMP1w
  //|  str BASE, L->base
  //|  str PC, SAVE_PC
  //|  bl extern lj_tab_setinth  // (lua_State *L, GCtab *t, int32_t key)
  //|  // Returns TValue *.
  //|  b ->BC_TSETR_Z
  //|
  //|//-- Comparison metamethods ---------------------------------------------
  //|
  //|->vmeta_comp:
  //|  add CARG2, BASE, RA, lsl #3
  //|   sub PC, PC, #4
  //|  add CARG3, BASE, RC, lsl #3
  //|   str BASE, L->base
  //|  mov CARG1, L
  dasm_put(Dst, 473, offsetof(global_State, tmptv), Dt1(->base), GG_G2DISP, FRAME_CONT, Dt1(->top), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), Dt1(->base));
#line 727 "vm_arm64.dasc"
  //|   str PC, SAVE_PC
  //|  uxtb CARG4w, INSw
  //|  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|3:
  //|  cmp CRET1, #1
  //|  bhi ->vmeta_binop
  //|4:
  //|   ldrh RBw, [PC, # OFS_RD]
  //|    add PC, PC, #4
  //|   add RB, PC, RB, lsl #2
  //|   sub RB, RB, #0x20000
  //|  csel PC, PC, RB, lo
  //|->cont_nop:
  //|  ins_next
  //|
  //|->cont_ra:				// RA = resultptr
  //|  ldr INSw, [PC, #-4]
  //|   ldr TMP0, [RA]
  //|  decode_RA TMP1, INS
  //|   str TMP0, [BASE, TMP1, lsl #3]
  //|  b ->cont_nop
  //|
  //|->cont_condt:			// RA = resultptr
  //|  ldr TMP0, [RA]
  //|   mov_true TMP1
  //|  cmp TMP1, TMP0			// Branch if result is true.
  //|  b <4
  //|
  //|->cont_condf:			// RA = resultptr
  //|  ldr TMP0, [RA]
  //|   mov_false TMP1
  //|  cmp TMP0, TMP1			// Branch if result is false.
  //|  b <4
  //|
  //|->vmeta_equal:
  //|  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  //|  and TAB:CARG3, CARG3, #LJ_GCVMASK
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|
  //|->vmeta_equal_cd:
  //|.if FFI
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|   mov CARG2, INS
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal_cd		// (lua_State *L, BCIns op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|.endif
  //|
  //|->vmeta_istype:
  //|  sub PC, PC, #4
  dasm_put(Dst, 538, GG_G2DISP, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), Dt1(->base));
#line 787 "vm_arm64.dasc"
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|   mov CARG2, RA
  //|   mov CARG3, RC
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_istype  // (lua_State *L, BCReg ra, BCReg tp)
  //|  b ->cont_nop
  //|
  //|//-- Arithmetic metamethods ---------------------------------------------
  //|
  //|->vmeta_arith_vn:
  //|  add CARG3, BASE, RB, lsl #3
  //|   add CARG4, KBASE, RC, lsl #3
  //|  b >1
  //|
  //|->vmeta_arith_nv:
  //|  add CARG4, BASE, RB, lsl #3
  //|   add CARG3, KBASE, RC, lsl #3
  //|  b >1
  //|
  //|->vmeta_unm:
  //|  add CARG3, BASE, RC, lsl #3
  //|  mov CARG4, CARG3
  //|  b >1
  //|
  //|->vmeta_arith_vv:
  //|  add CARG3, BASE, RB, lsl #3
  //|   add CARG4, BASE, RC, lsl #3
  //|1:
  //|  uxtb CARG5w, INSw
  //|   add CARG2, BASE, RA, lsl #3
  //|    str BASE, L->base
  //|   mov CARG1, L
  //|    str PC, SAVE_PC
  //|  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  //|  // Returns NULL (finished) or TValue * (metamethod).
  //|  cbz CRET1, ->cont_nop
  //|
  //|  // Call metamethod for binary op.
  //|->vmeta_binop:
  //|  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  //|  sub TMP1, CRET1, BASE
  //|   str PC, [CRET1, #-24]		// [cont|PC]
  //|  add PC, TMP1, #FRAME_CONT
  //|  mov BASE, CRET1
  //|   mov NARGS8:RC, #16		// 2 args for func(o1, o2).
  //|  b ->vm_call_dispatch
  //|
  //|->vmeta_len:
  //|  add CARG2, BASE, RC, lsl #3
  dasm_put(Dst, 605, Dt1(->base), Dt1(->base), FRAME_CONT);
#line 837 "vm_arm64.dasc"
#if LJ_52
  //|  mov TAB:RC, TAB:CARG1		// Save table (ignored for other types).
  dasm_put(Dst, 657);
#line 839 "vm_arm64.dasc"
#endif
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_len		// (lua_State *L, TValue *o)
  //|  // Returns NULL (retry) or TValue * (metamethod base).
  dasm_put(Dst, 659, Dt1(->base));
#line 845 "vm_arm64.dasc"
#if LJ_52
  //|  cbnz CRET1, ->vmeta_binop		// Binop call for compatibility.
  //|  mov TAB:CARG1, TAB:RC
  //|  b ->BC_LEN_Z
  dasm_put(Dst, 666);
#line 849 "vm_arm64.dasc"
#else
  //|  b ->vmeta_binop			// Binop call for compatibility.
  dasm_put(Dst, 672);
#line 851 "vm_arm64.dasc"
#endif
  //|
  //|//-- Call metamethod ----------------------------------------------------
  //|
  //|->vmeta_call:			// Resolve and call __call metamethod.
  //|  // RB = old base, BASE = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str RB, L->base			// This is the callers base!
  //|  sub CARG2, BASE, #16
  //|   str PC, SAVE_PC
  //|  add CARG3, BASE, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  ins_call
  //|
  //|->vmeta_callt:			// Resolve __call for BC_CALLT.
  //|  // BASE = old base, RA = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  sub CARG2, RA, #16
  //|   str PC, SAVE_PC
  //|  add CARG3, RA, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  ldr TMP1, [RA, FRAME_FUNC]		// Guaranteed to be a function here.
  //|   ldr PC, [BASE, FRAME_PC]
  //|   add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  and LFUNC:CARG3, TMP1, #LJ_GCVMASK
  //|  b ->BC_CALLT2_Z
  //|
  //|//-- Argument coercion for 'for' statement ------------------------------
  //|
  //|->vmeta_for:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, RA
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_for	// (lua_State *L, TValue *base)
  //|  ldr INSw, [PC, #-4]
  //|.if JIT
  //|   uxtb TMP0w, INSw
  //|.endif
  //|  decode_RA RA, INS
  //|  decode_RD RC, INS
  //|.if JIT
  //|   cmp TMP0, #BC_JFORI
  //|   beq =>BC_JFORI
  //|.endif
  //|  b =>BC_FORI
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Fast functions -----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro .ffunc, name
  //|->ff_ .. name:
  //|.endmacro
  //|
  //|.macro .ffunc_1, name
  //|->ff_ .. name:
  //|  ldr CARG1, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_2, name
  //|->ff_ .. name:
  //|  ldp CARG1, CARG2, [BASE]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_n, name
  //|  .ffunc name
  //|  ldr CARG1, [BASE]
  //|   cmp NARGS8:RC, #8
  //|  ldr FARG1, [BASE]
  //|   blo ->fff_fallback
  //|  checknum CARG1, ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_nn, name
  //|  .ffunc name
  //|  ldp CARG1, CARG2, [BASE]
  //|   cmp NARGS8:RC, #16
  //|  ldp FARG1, FARG2, [BASE]
  //|   blo ->fff_fallback
  //|  checknum CARG1, ->fff_fallback
  //|  checknum CARG2, ->fff_fallback
  //|.endmacro
  //|
  //|// Inlined GC threshold check. Caveat: uses CARG1 and CARG2.
  //|.macro ffgccheck
  //|  ldp CARG1, CARG2, GL->gc.total	// Assumes threshold follows total.
  //|  cmp CARG1, CARG2
  //|  blt >1
  //|  bl ->fff_gcstep
  //|1:
  //|.endmacro
  //|
  //|//-- Base library: checks -----------------------------------------------
  //|
  //|.ffunc_1 assert
  //|   ldr PC, [BASE, FRAME_PC]
  //|  mov_false TMP1
  //|  cmp CARG1, TMP1
  //|  bhs ->fff_fallback
  //|  str CARG1, [BASE, #-16]
  //|  sub RB, BASE, #8
  //|  subs RA, NARGS8:RC, #8
  //|   add RC, NARGS8:RC, #8		// Compute (nresults+1)*8.
  //|  cbz RA, ->fff_res			// Done if exactly 1 argument.
  //|1:
  //|   ldr CARG1, [RB, #16]
  dasm_put(Dst, 675, Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP, Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), BC_JFORI, BC_JFORI, BC_FORI);
#line 966 "vm_arm64.dasc"
  //|  sub RA, RA, #8
  //|   str CARG1, [RB], #8
  //|  cbnz RA, <1
  //|  b ->fff_res
  //|
  //|.ffunc_1 type
  //|  mov TMP0, #~LJ_TISNUM
  //|  asr ITYPE, CARG1, #47
  //|  cmn ITYPE, #~LJ_TISNUM
  //|  csinv TMP1, TMP0, ITYPE, lo
  //|  add TMP1, TMP1, #offsetof(GCfuncC, upvalue)/8
  //|  ldr CARG1, [CFUNC:CARG3, TMP1, lsl #3]
  //|  b ->fff_restv
  //|
  //|//-- Base library: getters and setters ---------------------------------
  //|
  //|.ffunc_1 getmetatable
  //|  asr ITYPE, CARG1, #47
  //|  cmn ITYPE, #-LJ_TTAB
  //|  ccmn ITYPE, #-LJ_TUDATA, #4, ne
  //|   and TAB:CARG1, CARG1, #LJ_GCVMASK
  //|  bne >6
  //|1:  // Field metatable must be at same offset for GCtab and GCudata!
  //|  ldr TAB:RB, TAB:CARG1->metatable
  //|2:
  //|   mov CARG1, TISNIL
  //|   ldr STR:RC, GL->gcroot[GCROOT_MMNAME+MM_metatable]
  //|  cbz TAB:RB, ->fff_restv
  //|  ldr TMP1w, TAB:RB->hmask
  //|   ldr TMP2w, STR:RC->hash
  //|    ldr NODE:CARG3, TAB:RB->node
  //|  and TMP1w, TMP1w, TMP2w		// idx = str->hash & tab->hmask
  dasm_put(Dst, 750, ~LJ_TISNUM, ~LJ_TISNUM, offsetof(GCfuncC, upvalue)/8, -LJ_TTAB, -LJ_TUDATA, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->metatable), Dt2(->gcroot[GCROOT_MMNAME+MM_metatable]), Dt6(->hmask), Dt5(->hash), Dt6(->node));
#line 998 "vm_arm64.dasc"
  //|  add TMP1, TMP1, TMP1, lsl #1
  //|  movn CARG4, #~LJ_TSTR
  //|    add NODE:CARG3, NODE:CARG3, TMP1, lsl #3  // node = tab->node + idx*3*8
  //|  add CARG4, STR:RC, CARG4, lsl #47	// Tagged key to look for.
  //|3:  // Rearranged logic, because we expect _not_ to find the key.
  //|  ldp CARG1, TMP0, NODE:CARG3->val
  //|   ldr NODE:CARG3, NODE:CARG3->next
  //|  cmp TMP0, CARG4
  //|  beq >5
  //|  cbnz NODE:CARG3, <3
  //|4:
  //|  mov CARG1, RB			// Use metatable as default result.
  //|  movk CARG1, #(LJ_TTAB>>1)&0xffff, lsl #48
  //|  b ->fff_restv
  //|5:
  //|  cmp TMP0, TISNIL
  //|  bne ->fff_restv
  //|  b <4
  //|
  //|6:
  //|  movn TMP0, #~LJ_TISNUM
  //|  cmp ITYPE, TMP0
  //|  csel ITYPE, ITYPE, TMP0, hs
  //|  sub TMP1, GL, ITYPE, lsl #3
  //|  ldr TAB:RB, [TMP1, #offsetof(global_State, gcroot[GCROOT_BASEMT])-8]
  //|  b <2
  //|
  //|.ffunc_2 setmetatable
  //|  // Fast path: no mt for table yet and not clearing the mt.
  //|  checktp TMP1, CARG1, LJ_TTAB, ->fff_fallback
  //|   ldr TAB:TMP0, TAB:TMP1->metatable
  //|  asr ITYPE, CARG2, #47
  dasm_put(Dst, 803, ~LJ_TSTR, DtB(->val), DtB(->next), (LJ_TTAB>>1)&0xffff, ~LJ_TISNUM, offsetof(global_State, gcroot[GCROOT_BASEMT])-8, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->metatable));
#line 1030 "vm_arm64.dasc"
  //|   ldrb TMP2w, TAB:TMP1->marked
  //|  cmn ITYPE, #-LJ_TTAB
  //|    and TAB:CARG2, CARG2, #LJ_GCVMASK
  //|  ccmp TAB:TMP0, #0, #0, eq
  //|  bne ->fff_fallback
  //|    str TAB:CARG2, TAB:TMP1->metatable
  //|   tbz TMP2w, #2, ->fff_restv	// isblack(table)
  //|  barrierback TAB:TMP1, TMP2w, TMP0
  //|  b ->fff_restv
  //|
  //|.ffunc rawget
  //|  ldr CARG2, [BASE]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|  checktab CARG2, ->fff_fallback
  //|   mov CARG1, L
  //|   add CARG3, BASE, #8
  //|  bl extern lj_tab_get  // (lua_State *L, GCtab *t, cTValue *key)
  //|  // Returns cTValue *.
  //|  ldr CARG1, [CRET1]
  //|  b ->fff_restv
  //|
  //|//-- Base library: conversions ------------------------------------------
  //|
  //|.ffunc tonumber
  //|  // Only handles the number case inline (without a base argument).
  //|  ldr CARG1, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   bne ->fff_fallback
  //|  checknumber CARG1, ->fff_fallback
  //|  b ->fff_restv
  dasm_put(Dst, 856, Dt6(->marked), -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->metatable), Dt2(->gc.grayagain), ~LJ_GC_BLACK, Dt2(->gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1061 "vm_arm64.dasc"
  //|
  //|.ffunc_1 tostring
  //|  // Only handles the string or number case inline.
  //|  asr ITYPE, CARG1, #47
  //|  cmn ITYPE, #-LJ_TSTR
  //|  // A __tostring method in the string base metatable is ignored.
  //|  beq ->fff_restv
  //|  // Handle numbers inline, unless a number base metatable is present.
  //|  ldr TMP1, GL->gcroot[GCROOT_BASEMT_NUM]
  //|   str BASE, L->base
  //|  cmn ITYPE, #-LJ_TISNUM
  //|  ccmp TMP1, #0, #0, ls
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  bne ->fff_fallback
  //|  ffgccheck
  //|  mov CARG1, L
  //|  mov CARG2, BASE
  //|  bl extern lj_strfmt_number		// (lua_State *L, cTValue *o)
  //|  // Returns GCstr *.
  //|   movn TMP1, #~LJ_TSTR
  //|  ldr BASE, L->base
  //|   add CARG1, CARG1, TMP1, lsl #47
  //|  b ->fff_restv
  //|
  //|//-- Base library: iterators -------------------------------------------
  //|
  //|.ffunc_1 next
  //|  checktp CARG2, CARG1, LJ_TTAB, ->fff_fallback
  //|  str TISNIL, [BASE, NARGS8:RC]	// Set missing 2nd arg to nil.
  dasm_put(Dst, 910, -LJ_TSTR, Dt2(->gcroot[GCROOT_BASEMT_NUM]), Dt1(->base), -LJ_TISNUM, Dt2(->gc.total), ~LJ_TSTR, Dt1(->base), -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1090 "vm_arm64.dasc"
  //|  ldr PC, [BASE, FRAME_PC]
  //|   stp BASE, BASE, L->base		// Add frame since C call can throw.
  //|  mov CARG1, L
  //|  add CARG3, BASE, #8
  //|   str PC, SAVE_PC
  //|  bl extern lj_tab_next	// (lua_State *L, GCtab *t, TValue *key)
  //|  // Returns 0 at end of traversal.
  //|  str TISNIL, [BASE, #-16]
  //|  cbz CRET1, ->fff_res1		// End of traversal: return nil.
  //|  ldp CARG1, CARG2, [BASE, #8]	// Copy key and value to results.
  //|    mov RC, #(2+1)*8
  //|  stp CARG1, CARG2, [BASE, #-16]
  //|  b ->fff_res
  //|
  //|.ffunc_1 pairs
  //|  checktp TMP1, CARG1, LJ_TTAB, ->fff_fallback
  dasm_put(Dst, 964, Dt1(->base), -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1106 "vm_arm64.dasc"
#if LJ_52
  //|  ldr TAB:CARG2, TAB:TMP1->metatable
  dasm_put(Dst, 994, Dt6(->metatable));
#line 1108 "vm_arm64.dasc"
#endif
  //|   ldr CFUNC:CARG4, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 997, Dt8(->upvalue[0]));
#line 1111 "vm_arm64.dasc"
#if LJ_52
  //|  cbnz TAB:CARG2, ->fff_fallback
  dasm_put(Dst, 1001);
#line 1113 "vm_arm64.dasc"
#endif
  //|  mov RC, #(3+1)*8
  //|  stp CARG1, TISNIL, [BASE, #-8]
  //|   str CFUNC:CARG4, [BASE, #-16]
  //|  b ->fff_res
  //|
  //|.ffunc_2 ipairs_aux
  //|  checktab CARG1, ->fff_fallback
  //|   checkint CARG2, ->fff_fallback
  //|  ldr TMP1w, TAB:CARG1->asize
  //|   ldr CARG3, TAB:CARG1->array
  //|    ldr TMP0w, TAB:CARG1->hmask
  //|  add CARG2w, CARG2w, #1
  //|  cmp CARG2w, TMP1w
  //|    ldr PC, [BASE, FRAME_PC]
  //|     add TMP2, CARG2, TISNUM
  //|   mov RC, #(0+1)*8
  //|     str TMP2, [BASE, #-16]
  //|  bhs >2				// Not in array part?
  //|  ldr TMP0, [CARG3, CARG2, lsl #3]
  //|1:
  //|   mov TMP1, #(2+1)*8
  //|   cmp TMP0, TISNIL
  //|  str TMP0, [BASE, #-8]
  //|   csel RC, RC, TMP1, eq
  //|  b ->fff_res
  //|2:  // Check for empty hash part first. Otherwise call C function.
  //|  cbz TMP0w, ->fff_res
  //|  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  //|  // Returns cTValue * or NULL.
  //|  cbz CRET1, ->fff_res
  //|  ldr TMP0, [CRET1]
  //|  b <1
  //|
  //|.ffunc_1 ipairs
  //|  checktp TMP1, CARG1, LJ_TTAB, ->fff_fallback
  dasm_put(Dst, 1004, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->asize), Dt6(->array), Dt6(->hmask), -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
  dasm_put(Dst, 1067);
#line 1149 "vm_arm64.dasc"
#if LJ_52
  //|  ldr TAB:CARG2, TAB:TMP1->metatable
  dasm_put(Dst, 1070, Dt6(->metatable));
#line 1151 "vm_arm64.dasc"
#endif
  //|   ldr CFUNC:CARG4, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 1073, Dt8(->upvalue[0]));
#line 1154 "vm_arm64.dasc"
#if LJ_52
  //|  cbnz TAB:CARG2, ->fff_fallback
  dasm_put(Dst, 1077);
#line 1156 "vm_arm64.dasc"
#endif
  //|  mov RC, #(3+1)*8
  //|  stp CARG1, TISNUM, [BASE, #-8]
  //|   str CFUNC:CARG4, [BASE, #-16]
  //|  b ->fff_res
  //|
  //|//-- Base library: catch errors ----------------------------------------
  //|
  //|.ffunc pcall
  //|  ldrb TMP0w, GL->hookmask
  //|   subs NARGS8:RC, NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|    mov RB, BASE
  //|    add BASE, BASE, #16
  //|  ubfx TMP0w, TMP0w, #HOOK_ACTIVE_SHIFT, #1
  //|  add PC, TMP0, #16+FRAME_PCALL
  //|   beq ->vm_call_dispatch
  //|1:
  //|   add TMP2, BASE, NARGS8:RC
  //|2:
  //|   ldr TMP0, [TMP2, #-16]
  //|   str TMP0, [TMP2, #-8]!
  //|  cmp TMP2, BASE
  //|  bne <2
  //|  b ->vm_call_dispatch
  //|
  //|.ffunc xpcall
  //|     ldp CARG1, CARG2, [BASE]
  //|  ldrb TMP0w, GL->hookmask
  //|   subs NARGS8:RC, NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|    mov RB, BASE
  //|    add BASE, BASE, #24
  //|     asr ITYPE, CARG2, #47
  //|  ubfx TMP0w, TMP0w, #HOOK_ACTIVE_SHIFT, #1
  //|     cmn ITYPE, #-LJ_TFUNC
  //|  add PC, TMP0, #24+FRAME_PCALL
  //|     bne ->fff_fallback		// Traceback must be a function.
  //|     stp CARG2, CARG1, [RB]		// Swap function and traceback.
  //|   cbz NARGS8:RC, ->vm_call_dispatch
  //|  b <1
  //|
  //|//-- Coroutine library --------------------------------------------------
  //|
  //|.macro coroutine_resume_wrap, resume
  //|.if resume
  //|.ffunc_1 coroutine_resume
  //|  checktp CARG1, LJ_TTHREAD, ->fff_fallback
  //|.else
  //|.ffunc coroutine_wrap_aux
  //|  ldr L:CARG1, CFUNC:CARG3->upvalue[0].gcr
  //|  and L:CARG1, CARG1, #LJ_GCVMASK
  //|.endif
  //|   ldr PC, [BASE, FRAME_PC]
  //|     str BASE, L->base
  //|  ldp RB, CARG2, L:CARG1->base
  //|   ldrb TMP1w, L:CARG1->status
  //|  add TMP0, CARG2, TMP1
  //|   str PC, SAVE_PC
  //|  cmp TMP0, RB
  //|  beq ->fff_fallback
  //|   cmp TMP1, #LUA_YIELD
  //|    add TMP0, CARG2, #8
  //|   csel CARG2, CARG2, TMP0, hs
  //|   ldr CARG4, L:CARG1->maxstack
  //|   add CARG3, CARG2, NARGS8:RC
  //|    ldr RB, L:CARG1->cframe
  //|   ccmp CARG3, CARG4, #2, ls
  //|    ccmp RB, #0, #2, ls
  //|    bhi ->fff_fallback
  //|.if resume
  //|  sub CARG3, CARG3, #8		// Keep resumed thread in stack for GC.
  //|  add BASE, BASE, #8
  //|  sub NARGS8:RC, NARGS8:RC, #8
  //|.endif
  //|  str CARG3, L:CARG1->top
  //|  str BASE, L->top
  //|  cbz NARGS8:RC, >3
  //|2:  // Move args to coroutine.
  //|   ldr TMP0, [BASE, RB]
  //|  cmp RB, NARGS8:RC
  //|   str TMP0, [CARG2, RB]
  //|   add RB, RB, #8
  //|  bne <2
  //|3:
  //|  mov CARG3, #0
  //|   mov L:RA, L:CARG1
  //|  mov CARG4, #0
  //|  bl ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
  //|  // Returns thread status.
  //|4:
  //|  ldp CARG3, CARG4, L:RA->base
  //|   cmp CRET1, #LUA_YIELD
  //|  ldr BASE, L->base
  //|    str L, GL->cur_L
  //|    st_vmstate ST_INTERP
  //|   bhi >8
  //|  sub RC, CARG4, CARG3
  //|   ldr CARG1, L->maxstack
  //|   add CARG2, BASE, RC
  //|  cbz RC, >6				// No results?
  //|  cmp CARG2, CARG1
  //|   mov RB, #0
  //|  bhi >9				// Need to grow stack?
  //|
  //|  sub CARG4, RC, #8
  //|   str CARG3, L:RA->top		// Clear coroutine stack.
  //|5:  // Move results from coroutine.
  //|   ldr TMP0, [CARG3, RB]
  //|  cmp RB, CARG4
  //|   str TMP0, [BASE, RB]
  //|   add RB, RB, #8
  //|  bne <5
  //|6:
  //|.if resume
  //|  mov_true TMP1
  //|   add RC, RC, #16
  //|7:
  //|  str TMP1, [BASE, #-8]		// Prepend true/false to results.
  //|   sub RA, BASE, #8
  //|.else
  //|   mov RA, BASE
  //|   add RC, RC, #8
  //|.endif
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   str PC, SAVE_PC
  //|   str RCw, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|8:  // Coroutine returned with error (at co->top-1).
  //|.if resume
  //|  ldr TMP0, [CARG4, #-8]!
  //|   mov_false TMP1
  //|    mov RC, #(2+1)*8
  //|  str CARG4, L:RA->top		// Remove error from coroutine stack.
  //|  str TMP0, [BASE]			// Copy error message.
  //|  b <7
  //|.else
  //|  mov CARG1, L
  //|  mov CARG2, L:RA
  //|  bl extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  //|  // Never returns.
  //|.endif
  //|
  //|9:  // Handle stack expansion on return from yield.
  //|  mov CARG1, L
  //|  lsr CARG2, RC, #3
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  mov CRET1, #0
  //|  b <4
  //|.endmacro
  //|
  //|  coroutine_resume_wrap 1		// coroutine.resume
  dasm_put(Dst, 1080, Dt2(->hookmask), HOOK_ACTIVE_SHIFT, (HOOK_ACTIVE_SHIFT)+(1)-1, 16+FRAME_PCALL, Dt2(->hookmask), HOOK_ACTIVE_SHIFT, (HOOK_ACTIVE_SHIFT)+(1)-1, -LJ_TFUNC, 24+FRAME_PCALL);
  dasm_put(Dst, 1136, -LJ_TTHREAD, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), Dt1(->base), Dt1(->status), LUA_YIELD, Dt1(->maxstack), Dt1(->cframe), Dt1(->top), Dt1(->top), Dt1(->base), LUA_YIELD);
#line 1310 "vm_arm64.dasc"
  //|  coroutine_resume_wrap 0		// coroutine.wrap
  dasm_put(Dst, 1200, Dt1(->base), Dt2(->cur_L), Dt2(->vmstate), Dt1(->maxstack), Dt1(->top), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), Dt1(->top));
  dasm_put(Dst, 1261, Dt8(->upvalue[0].gcr), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), Dt1(->base), Dt1(->status), LUA_YIELD, Dt1(->maxstack), Dt1(->cframe), Dt1(->top), Dt1(->top), Dt1(->base), LUA_YIELD, Dt1(->base), Dt2(->cur_L));
#line 1311 "vm_arm64.dasc"
  //|
  //|.ffunc coroutine_yield
  //|  ldr TMP0, L->cframe
  //|   add TMP1, BASE, NARGS8:RC
  //|    mov CRET1, #LUA_YIELD
  //|   stp BASE, TMP1, L->base
  //|  tbz TMP0, #0, ->fff_fallback
  //|   str xzr, L->cframe
  dasm_put(Dst, 1319, Dt2(->vmstate), Dt1(->maxstack), Dt1(->top), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), Dt1(->cframe), LUA_YIELD, Dt1(->base));
#line 1319 "vm_arm64.dasc"
  //|    strb CRET1w, L->status
  //|  b ->vm_leave_unw
  //|
  //|//-- Math library -------------------------------------------------------
  //|
  //|.macro math_round, func, round
  //|  .ffunc math_ .. func
  //|  ldr CARG1, [BASE]
  //|   cmp NARGS8:RC, #8
  //|  ldr d0, [BASE]
  //|   blo ->fff_fallback
  //|  cmp TISNUMhi, CARG1, lsr #32
  //|  beq ->fff_restv
  //|  blo ->fff_fallback
  //|  round d0, d0
  //|  b ->fff_resn
  //|.endmacro
  //|
  //|  math_round floor, frintm
  //|  math_round ceil, frintp
  //|
  //|.ffunc_1 math_abs
  //|  checknumber CARG1, ->fff_fallback
  //|  and CARG1, CARG1, #U64x(7fffffff,ffffffff)
  //|  bne ->fff_restv
  //|  eor CARG2w, CARG1w, CARG1w, asr #31
  //|   movz CARG3, #0x41e0, lsl #48	// 2^31.
  //|  subs CARG1w, CARG2w, CARG1w, asr #31
  //|   add CARG1, CARG1, TISNUM
  //|  csel CARG1, CARG1, CARG3, pl
  //|  // Fallthrough.
  //|
  //|->fff_restv:
  //|  // CARG1 = TValue result.
  //|  ldr PC, [BASE, FRAME_PC]
  //|  str CARG1, [BASE, #-16]
  //|->fff_res1:
  //|  // PC = return.
  //|  mov RC, #(1+1)*8
  //|->fff_res:
  //|  // RC = (nresults+1)*8, PC = return.
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   str RCw, SAVE_MULTRES
  dasm_put(Dst, 1378, Dt1(->cframe), Dt1(->status), (unsigned int)(U64x(7fffffff,ffffffff)), (unsigned int)((unsigned long long)(U64x(7fffffff,ffffffff))>>32), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32));
#line 1362 "vm_arm64.dasc"
  //|   sub RA, BASE, #16
  //|  bne ->vm_return
  //|  ldr INSw, [PC, #-4]
  //|  decode_RB RB, INS
  //|5:
  //|  cmp RC, RB, lsl #3			// More results expected?
  //|  blo >6
  //|  decode_RA TMP1, INS
  //|  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  //|  sub BASE, RA, TMP1, lsl #3
  //|  ins_next
  //|
  //|6:  // Fill up results with nil.
  //|  add TMP1, RA, RC
  //|   add RC, RC, #8
  //|  str TISNIL, [TMP1, #-8]
  //|  b <5
  //|
  //|.macro math_extern, func
  //|  .ffunc_n math_ .. func
  //|  bl extern func
  //|  b ->fff_resn
  //|.endmacro
  //|
  //|.macro math_extern2, func
  //|  .ffunc_nn math_ .. func
  //|  bl extern func
  //|  b ->fff_resn
  //|.endmacro
  //|
  //|.ffunc_n math_sqrt
  //|  fsqrt d0, d0
  //|->fff_resn:
  //|  ldr PC, [BASE, FRAME_PC]
  //|  str d0, [BASE, #-16]
  //|  b ->fff_res1
  //|
  //|.ffunc math_log
  //|  ldr CARG1, [BASE]
  //|   cmp NARGS8:RC, #8
  //|  ldr FARG1, [BASE]
  //|   bne ->fff_fallback			// Need exactly 1 argument.
  //|  checknum CARG1, ->fff_fallback
  //|  bl extern log
  //|  b ->fff_resn
  //|
  //|  math_extern log10
  //|  math_extern exp
  dasm_put(Dst, 1438, GG_G2DISP);
#line 1410 "vm_arm64.dasc"
  //|  math_extern sin
  //|  math_extern cos
  //|  math_extern tan
  //|  math_extern asin
  dasm_put(Dst, 1506);
#line 1414 "vm_arm64.dasc"
  //|  math_extern acos
  //|  math_extern atan
  //|  math_extern sinh
  //|  math_extern cosh
  //|  math_extern tanh
  dasm_put(Dst, 1567);
#line 1419 "vm_arm64.dasc"
  //|  math_extern2 pow
  //|  math_extern2 atan2
  //|  math_extern2 fmod
  //|
  //|.ffunc_2 math_ldexp
  dasm_put(Dst, 1625);
#line 1424 "vm_arm64.dasc"
  //|  ldr FARG1, [BASE]
  //|  checknum CARG1, ->fff_fallback
  //|  checkint CARG2, ->fff_fallback
  //|  sxtw CARG1, CARG2w
  //|  bl extern ldexp			// (double x, int exp)
  //|  b ->fff_resn
  //|
  //|.ffunc_n math_frexp
  //|  add CARG1, sp, TMPDofs
  //|  bl extern frexp
  //|   ldr CARG2w, TMPD
  //|    ldr PC, [BASE, FRAME_PC]
  //|  str d0, [BASE, #-16]
  //|    mov RC, #(2+1)*8
  //|   add CARG2, CARG2, TISNUM
  //|   str CARG2, [BASE, #-8]
  //|  b ->fff_res
  //|
  //|.ffunc_n math_modf
  //|  sub CARG1, BASE, #16
  //|   ldr PC, [BASE, FRAME_PC]
  //|  bl extern modf
  //|   mov RC, #(2+1)*8
  //|  str d0, [BASE, #-8]
  //|  b ->fff_res
  //|
  //|.macro math_minmax, name, cond, fcond
  //|  .ffunc_1 name
  //|   add RB, BASE, RC
  //|   add RA, BASE, #8
  //|  checkint CARG1, >4
  //|1:  // Handle integers.
  //|  ldr CARG2, [RA]
  //|   cmp RA, RB
  //|   bhs ->fff_restv
  //|  checkint CARG2, >3
  //|  cmp CARG1w, CARG2w
  //|   add RA, RA, #8
  //|  csel CARG1, CARG2, CARG1, cond
  //|  b <1
  //|3:  // Convert intermediate result to number and continue below.
  //|  scvtf d0, CARG1w
  //|  blo ->fff_fallback
  //|  ldr d1, [RA]
  //|  b >6
  //|
  //|4:
  //|  ldr d0, [BASE]
  //|  blo ->fff_fallback
  //|5:  // Handle numbers.
  //|  ldr CARG2, [RA]
  //|  ldr d1, [RA]
  //|   cmp RA, RB
  //|   bhs ->fff_resn
  //|  checknum CARG2, >7
  //|6:
  //|  fcmp d0, d1
  //|   add RA, RA, #8
  //|  fcsel d0, d1, d0, fcond
  //|  b <5
  //|7:  // Convert integer to number and continue above.
  //|  scvtf d1, CARG2w
  //|  blo ->fff_fallback
  //|  b <6
  //|.endmacro
  //|
  //|  math_minmax math_min, gt, hi
  dasm_put(Dst, 1687);
#line 1491 "vm_arm64.dasc"
  //|  math_minmax math_max, lt, lo
  dasm_put(Dst, 1765);
#line 1492 "vm_arm64.dasc"
  //|
  //|//-- String library -----------------------------------------------------
  //|
  //|.ffunc string_byte			// Only handle the 1-arg case here.
  //|  ldp PC, CARG1, [BASE, FRAME_PC]
  //|   cmp NARGS8:RC, #8
  //|  asr ITYPE, CARG1, #47
  //|  ccmn ITYPE, #-LJ_TSTR, #0, eq
  //|   and STR:CARG1, CARG1, #LJ_GCVMASK
  //|  bne ->fff_fallback
  //|  ldrb TMP0w, STR:CARG1[1]		// Access is always ok (NUL at end).
  //|   ldr CARG3w, STR:CARG1->len
  //|  add TMP0, TMP0, TISNUM
  //|  str TMP0, [BASE, #-16]
  //|  mov RC, #(0+1)*8
  //|   cbz CARG3, ->fff_res
  //|  b ->fff_res1
  //|
  //|.ffunc string_char			// Only handle the 1-arg case here.
  //|  ffgccheck
  //|  ldp PC, CARG1, [BASE, FRAME_PC]
  dasm_put(Dst, 1828, -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt5([1]), Dt5(->len), Dt2(->gc.total));
#line 1513 "vm_arm64.dasc"
  //|  cmp CARG1w, #255
  //|   ccmp NARGS8:RC, #8, #0, ls		// Need exactly 1 argument.
  //|  bne ->fff_fallback
  //|  checkint CARG1, ->fff_fallback
  //|  mov CARG3, #1
  //|  // Point to the char inside the integer in the stack slot.
  //|.if ENDIAN_LE
  //|  mov CARG2, BASE
  //|.else
  //|  add CARG2, BASE, #7
  //|.endif
  //|->fff_newstr:
  //|  // CARG2 = str, CARG3 = len.
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_str_new		// (lua_State *L, char *str, size_t l)
  //|->fff_resstr:
  //|  // Returns GCstr *.
  //|  ldr BASE, L->base
  //|   movn TMP1, #~LJ_TSTR
  //|  add CARG1, CARG1, TMP1, lsl #47
  //|  b ->fff_restv
  //|
  //|.ffunc string_sub
  //|  ffgccheck
  //|  ldr CARG1, [BASE]
  //|    ldr CARG3, [BASE, #16]
  //|   cmp NARGS8:RC, #16
  //|    movn RB, #0
  //|   beq >1
  //|   blo ->fff_fallback
  //|    checkint CARG3, ->fff_fallback
  //|    sxtw RB, CARG3w
  //|1:
  //|  ldr CARG2, [BASE, #8]
  //|  checkstr CARG1, ->fff_fallback
  //|   ldr TMP1w, STR:CARG1->len
  //|  checkint CARG2, ->fff_fallback
  dasm_put(Dst, 1883, Dt1(->base), Dt1(->base), ~LJ_TSTR, Dt2(->gc.total), -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt5(->len));
#line 1552 "vm_arm64.dasc"
  //|  sxtw CARG2, CARG2w
  //|  // CARG1 = str, TMP1 = str->len, CARG2 = start, RB = end
  //|   add TMP2, RB, TMP1
  //|   cmp RB, #0
  //|  add TMP0, CARG2, TMP1
  //|   csinc RB, RB, TMP2, ge		// if (end < 0) end += len+1
  //|  cmp CARG2, #0
  //|  csinc CARG2, CARG2, TMP0, ge	// if (start < 0) start += len+1
  //|   cmp RB, #0
  //|   csel RB, RB, xzr, ge		// if (end < 0) end = 0
  //|  cmp CARG2, #1
  //|  csinc CARG2, CARG2, xzr, ge	// if (start < 1) start = 1
  //|   cmp RB, TMP1
  //|   csel RB, RB, TMP1, le		// if (end > len) end = len
  //|  add CARG1, STR:CARG1, #sizeof(GCstr)-1
  //|   subs CARG3, RB, CARG2		// len = end - start
  //|  add CARG2, CARG1, CARG2
  //|   add CARG3, CARG3, #1		// len += 1
  //|   bge ->fff_newstr
  //|  add STR:CARG1, GL, #offsetof(global_State, strempty)
  //|   movn TMP1, #~LJ_TSTR
  //|  add CARG1, CARG1, TMP1, lsl #47
  //|  b ->fff_restv
  //|
  //|.macro ffstring_op, name
  //|  .ffunc string_ .. name
  //|  ffgccheck
  //|  ldr CARG2, [BASE]
  //|   cmp NARGS8:RC, #8
  //|  asr ITYPE, CARG2, #47
  //|  ccmn ITYPE, #-LJ_TSTR, #0, hs
  //|   and STR:CARG2, CARG2, #LJ_GCVMASK
  //|  bne ->fff_fallback
  //|  ldr TMP0, GL->tmpbuf.b
  //|   add SBUF:CARG1, GL, #offsetof(global_State, tmpbuf)
  //|   str BASE, L->base
  //|   str PC, SAVE_PC
  //|   str L, GL->tmpbuf.L
  //|  str TMP0, GL->tmpbuf.p
  //|  bl extern lj_buf_putstr_ .. name
  //|  bl extern lj_buf_tostr
  //|  b ->fff_resstr
  //|.endmacro
  //|
  //|ffstring_op reverse
  //|ffstring_op lower
  dasm_put(Dst, 1941, sizeof(GCstr)-1, offsetof(global_State, strempty), ~LJ_TSTR, Dt2(->gc.total), -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt2(->tmpbuf.b), offsetof(global_State, tmpbuf), Dt1(->base), Dt2(->tmpbuf.L), Dt2(->tmpbuf.p));
#line 1598 "vm_arm64.dasc"
  //|ffstring_op upper
  dasm_put(Dst, 2008, Dt2(->gc.total), -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt2(->tmpbuf.b), offsetof(global_State, tmpbuf), Dt1(->base), Dt2(->tmpbuf.L), Dt2(->tmpbuf.p), Dt2(->gc.total), -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1599 "vm_arm64.dasc"
  //|
  //|//-- Bit library --------------------------------------------------------
  //|
  //|// FP number to bit conversion for soft-float. Clobbers CARG1-CARG3
  //|->vm_tobit_fb:
  //|  bls ->fff_fallback
  //|  add CARG2, CARG1, CARG1
  //|  mov CARG3, #1076
  //|  sub CARG3, CARG3, CARG2, lsr #53
  //|  cmp CARG3, #53
  //|  bhi >1
  //|  and CARG2, CARG2, #U64x(001fffff,ffffffff)
  //|  orr CARG2, CARG2, #U64x(00200000,00000000)
  //|   cmp CARG1, #0
  //|  lsr CARG2, CARG2, CARG3
  //|   cneg CARG1w, CARG2w, mi
  //|  br lr
  //|1:
  //|  mov CARG1w, #0
  //|  br lr
  //|
  //|.macro .ffunc_bit, name
  //|  .ffunc_1 bit_..name
  //|  adr lr, >1
  //|  checkint CARG1, ->vm_tobit_fb
  //|1:
  //|.endmacro
  //|
  //|.macro .ffunc_bit_op, name, ins
  //|  .ffunc_bit name
  //|  mov RA, #8
  //|  mov TMP0w, CARG1w
  //|  adr lr, >2
  //|1:
  //|  ldr CARG1, [BASE, RA]
  //|   cmp RA, NARGS8:RC
  //|    add RA, RA, #8
  //|   bge >9
  //|  checkint CARG1, ->vm_tobit_fb
  //|2:
  //|  ins TMP0w, TMP0w, CARG1w
  //|  b <1
  //|.endmacro
  //|
  //|.ffunc_bit_op band, and
  dasm_put(Dst, 2059, Dt2(->tmpbuf.b), offsetof(global_State, tmpbuf), Dt1(->base), Dt2(->tmpbuf.L), Dt2(->tmpbuf.p), (unsigned int)(U64x(001fffff,ffffffff)), (unsigned int)((unsigned long long)(U64x(001fffff,ffffffff))>>32), (unsigned int)(U64x(00200000,00000000)), (unsigned int)((unsigned long long)(U64x(00200000,00000000))>>32));
#line 1644 "vm_arm64.dasc"
  //|.ffunc_bit_op bor, orr
  //|.ffunc_bit_op bxor, eor
  dasm_put(Dst, 2115);
#line 1646 "vm_arm64.dasc"
  //|
  //|.ffunc_bit tobit
  //|  mov TMP0w, CARG1w
  //|9:  // Label reused by .ffunc_bit_op users.
  //|  add CARG1, TMP0, TISNUM
  //|  b ->fff_restv
  //|
  //|.ffunc_bit bswap
  //|  rev TMP0w, CARG1w
  //|  add CARG1, TMP0, TISNUM
  //|  b ->fff_restv
  //|
  //|.ffunc_bit bnot
  //|  mvn TMP0w, CARG1w
  dasm_put(Dst, 2172);
#line 1660 "vm_arm64.dasc"
  //|  add CARG1, TMP0, TISNUM
  //|  b ->fff_restv
  //|
  //|.macro .ffunc_bit_sh, name, ins, shmod
  //|  .ffunc bit_..name
  //|  ldp TMP0, CARG1, [BASE]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|  adr lr, >1
  //|  checkint CARG1, ->vm_tobit_fb
  //|1:
  //|.if shmod == 0
  //|  mov TMP1, CARG1
  //|.else
  //|  neg TMP1, CARG1
  //|.endif
  //|  mov CARG1, TMP0
  //|  adr lr, >2
  //|  checkint CARG1, ->vm_tobit_fb
  //|2:
  //|  ins TMP0w, CARG1w, TMP1w
  //|  add CARG1, TMP0, TISNUM
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|.ffunc_bit_sh lshift, lsl, 0
  //|.ffunc_bit_sh rshift, lsr, 0
  //|.ffunc_bit_sh arshift, asr, 0
  dasm_put(Dst, 2227);
#line 1688 "vm_arm64.dasc"
  //|.ffunc_bit_sh rol, ror, 1
  //|.ffunc_bit_sh ror, ror, 0
  dasm_put(Dst, 2285);
#line 1690 "vm_arm64.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->fff_fallback:			// Call fast function fallback handler.
  //|  // BASE = new base, RC = nargs*8
  //|   ldp CFUNC:CARG3, PC, [BASE, FRAME_FUNC]	// Fallback may overwrite PC.
  //|  ldr TMP2, L->maxstack
  //|  add TMP1, BASE, NARGS8:RC
  //|  stp BASE, TMP1, L->base
  //|   and CFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  add TMP1, TMP1, #8*LUA_MINSTACK
  //|   ldr CARG3, CFUNC:CARG3->f
  //|    str PC, SAVE_PC			// Redundant (but a defined value).
  //|  cmp TMP1, TMP2
  //|   mov CARG1, L
  //|  bhi >5				// Need to grow stack.
  //|   blr CARG3				// (lua_State *L)
  //|  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  //|   ldr BASE, L->base
  //|  cmp CRET1w, #0
  //|   lsl RC, CRET1, #3
  //|   sub RA, BASE, #16
  //|  bgt ->fff_res			// Returned nresults+1?
  //|1:  // Returned 0 or -1: retry fast path.
  //|   ldr CARG1, L->top
  //|    ldr CFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   sub NARGS8:RC, CARG1, BASE
  //|  bne ->vm_call_tail			// Returned -1?
  //|    and CFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  ins_callt				// Returned 0: retry fast path.
  //|
  //|// Reconstruct previous base for vmeta_call during tailcall.
  //|->vm_call_tail:
  //|  ands TMP0, PC, #FRAME_TYPE
  //|   and TMP1, PC, #~FRAME_TYPEP
  //|  bne >3
  //|  ldrb RAw, [PC, #-4+OFS_RA]
  //|  lsl RA, RA, #3
  //|  add TMP1, RA, #16
  //|3:
  //|  sub RB, BASE, TMP1
  //|  b ->vm_call_dispatch		// Resolve again for tailcall.
  //|
  //|5:  // Grow stack for fallback handler.
  //|  mov CARG2, #LUA_MINSTACK
  dasm_put(Dst, 2344, Dt1(->maxstack), Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), 8*LUA_MINSTACK, Dt8(->f), Dt1(->base), Dt1(->top), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP, (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), (unsigned int)(~FRAME_TYPEP), (unsigned int)((unsigned long long)(~FRAME_TYPEP)>>32));
#line 1735 "vm_arm64.dasc"
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->base
  //|  cmp CARG1, CARG1			// Set zero-flag to force retry.
  //|  b <1
  //|
  //|->fff_gcstep:			// Call GC step function.
  //|  // BASE = new base, RC = nargs*8
  //|   add CARG2, BASE, NARGS8:RC	// Calculate L->top.
  //|  mov RA, lr
  //|   stp BASE, CARG2, L->base
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  mov CARG1, L
  //|  bl extern lj_gc_step		// (lua_State *L)
  //|  ldp BASE, CARG2, L->base
  //|   ldr CFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  mov lr, RA				// Help return address predictor.
  //|  sub NARGS8:RC, CARG2, BASE		// Calculate nargs*8.
  //|   and CFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  ret
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Special dispatch targets -------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_record:				// Dispatch target for recording phase.
  //|.if JIT
  //|  ldrb CARG1w, GL->hookmask
  //|  tst CARG1, #HOOK_VMEVENT		// No recording while in vmevent.
  //|  bne >5
  //|  // Decrement the hookcount for consistency, but always do the call.
  //|   ldr CARG2w, GL->hookcount
  //|  tst CARG1, #HOOK_ACTIVE
  //|  bne >1
  //|   sub CARG2w, CARG2w, #1
  //|  tst CARG1, #LUA_MASKLINE|LUA_MASKCOUNT
  //|  beq >1
  //|   str CARG2w, GL->hookcount
  //|  b >1
  //|.endif
  //|
  //|->vm_rethook:			// Dispatch target for return hooks.
  //|  ldrb TMP2w, GL->hookmask
  //|  tbz TMP2w, #HOOK_ACTIVE_SHIFT, >1	// Hook already active?
  dasm_put(Dst, 2408, LUA_MINSTACK, Dt1(->base), Dt1(->base), Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt2(->hookmask), (unsigned int)(HOOK_VMEVENT), (unsigned int)((unsigned long long)(HOOK_VMEVENT)>>32), Dt2(->hookcount), (unsigned int)(HOOK_ACTIVE), (unsigned int)((unsigned long long)(HOOK_ACTIVE)>>32), (unsigned int)(LUA_MASKLINE|LUA_MASKCOUNT), (unsigned int)((unsigned long long)(LUA_MASKLINE|LUA_MASKCOUNT)>>32), Dt2(->hookcount), Dt2(->hookmask));
#line 1778 "vm_arm64.dasc"
  //|5:  // Re-dispatch to static ins.
  //|  ldr TMP0, [TMP1, #GG_G2DISP+GG_DISP2STATIC]
  //|  br TMP0
  //|
  //|->vm_inshook:			// Dispatch target for instr/line hooks.
  //|  ldrb TMP2w, GL->hookmask
  //|   ldr TMP3w, GL->hookcount
  //|  tbnz TMP2w, #HOOK_ACTIVE_SHIFT, <5	// Hook already active?
  //|  tst TMP2w, #LUA_MASKLINE|LUA_MASKCOUNT
  //|  beq <5
  //|   sub TMP3w, TMP3w, #1
  //|   str TMP3w, GL->hookcount
  //|   cbz TMP3w, >1
  //|  tbz TMP2w, #LUA_HOOKLINE, <5
  //|1:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, PC
  //|  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  //|  bl extern lj_dispatch_ins		// (lua_State *L, const BCIns *pc)
  //|3:
  //|  ldr BASE, L->base
  //|4:  // Re-dispatch to static ins.
  //|  ldr INSw, [PC, #-4]
  //|  add TMP1, GL, INS, uxtb #3
  //|   decode_RA RA, INS
  //|  ldr TMP0, [TMP1, #GG_G2DISP+GG_DISP2STATIC]
  //|   decode_RD RC, INS
  dasm_put(Dst, 2460, HOOK_ACTIVE_SHIFT, GG_G2DISP+GG_DISP2STATIC, Dt2(->hookmask), Dt2(->hookcount), HOOK_ACTIVE_SHIFT, LUA_MASKLINE|LUA_MASKCOUNT, Dt2(->hookcount), LUA_HOOKLINE, Dt1(->base), Dt1(->base), GG_G2DISP+GG_DISP2STATIC);
#line 1806 "vm_arm64.dasc"
  //|  br TMP0
  //|
  //|->cont_hook:				// Continue from hook yield.
  //|  ldr CARG1, [CARG4, #-40]
  //|   add PC, PC, #4
  //|  str CARG1w, SAVE_MULTRES		// Restore MULTRES for *M ins.
  //|  b <4
  //|
  //|->vm_hotloop:			// Hot loop counter underflow.
  //|.if JIT
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Same as curr_topL(L).
  //|   add CARG1, GL, #GG_G2DISP+GG_DISP2J
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|   str PC, SAVE_PC
  //|  ldr CARG3, LFUNC:CARG3->pc
  //|   mov CARG2, PC
  //|   str L, [GL, #GL_J(L)]
  //|  ldrb CARG3w, [CARG3, #PC2PROTO(framesize)]
  //|   str BASE, L->base
  //|  add CARG3, BASE, CARG3, lsl #3
  //|  str CARG3, L->top
  //|  bl extern lj_trace_hot		// (jit_State *J, const BCIns *pc)
  //|  b <3
  //|.endif
  //|
  //|->vm_callhook:			// Dispatch target for call hooks.
  //|  mov CARG2, PC
  //|.if JIT
  //|  b >1
  //|.endif
  //|
  //|->vm_hotcall:			// Hot call counter underflow.
  //|.if JIT
  //|  orr CARG2, PC, #1
  //|1:
  //|.endif
  //|  add TMP1, BASE, NARGS8:RC
  //|   str PC, SAVE_PC
  //|   mov CARG1, L
  //|   sub RA, RA, BASE
  //|  stp BASE, TMP1, L->base
  //|  bl extern lj_dispatch_call		// (lua_State *L, const BCIns *pc)
  //|  // Returns ASMFunction.
  //|  ldp BASE, TMP1, L->base
  //|   str xzr, SAVE_PC			// Invalidate for subsequent line hook.
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  add RA, BASE, RA
  //|  sub NARGS8:RC, TMP1, BASE
  //|   ldr INSw, [PC, #-4]
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  br CRET1
  //|
  //|->cont_stitch:			// Trace stitching.
  //|.if JIT
  //|  // RA = resultptr, CARG4 = meta base
  //|   ldr RBw, SAVE_MULTRES
  //|  ldr INSw, [PC, #-4]
  //|    ldr TRACE:CARG3, [CARG4, #-40]	// Save previous trace.
  //|   subs RB, RB, #8
  //|  decode_RA RC, INS			// Call base.
  //|    and CARG3, CARG3, #LJ_GCVMASK
  //|   beq >2
  dasm_put(Dst, 2504, GG_G2DISP+GG_DISP2J, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GL_J(L), PC2PROTO(framesize), Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1868 "vm_arm64.dasc"
  //|1:  // Move results down.
  //|  ldr CARG1, [RA]
  //|    add RA, RA, #8
  //|   subs RB, RB, #8
  //|  str CARG1, [BASE, RC, lsl #3]
  //|    add RC, RC, #1
  //|   bne <1
  //|2:
  //|   decode_RA RA, INS
  //|   decode_RB RB, INS
  //|   add RA, RA, RB
  //|3:
  //|   cmp RA, RC
  //|   bhi >9				// More results wanted?
  //|
  //|  ldrh RAw, TRACE:CARG3->traceno
  //|  ldrh RCw, TRACE:CARG3->link
  //|  cmp RCw, RAw
  //|  beq ->cont_nop			// Blacklisted.
  //|  cmp RCw, #0
  //|  bne =>BC_JLOOP			// Jump to stitched trace.
  //|
  //|  // Stitch a new trace to the previous trace.
  //|  mov CARG1, #GL_J(exitno)
  //|  str RAw, [GL, CARG1]
  //|  mov CARG1, #GL_J(L)
  //|  str L, [GL, CARG1]
  //|  str BASE, L->base
  //|  add CARG1, GL, #GG_G2J
  //|  mov CARG2, PC
  //|  bl extern lj_dispatch_stitch	// (jit_State *J, const BCIns *pc)
  //|  ldr BASE, L->base
  //|  b ->cont_nop
  //|
  //|9:  // Fill up results with nil.
  //|  str TISNIL, [BASE, RC, lsl #3]
  //|  add RC, RC, #1
  //|  b <3
  //|.endif
  //|
  //|->vm_profhook:			// Dispatch target for profiler hook.
  dasm_put(Dst, 2569, DtD(->traceno), DtD(->link), BC_JLOOP, GL_J(exitno), GL_J(L), Dt1(->base), GG_G2J, Dt1(->base));
#line 1909 "vm_arm64.dasc"
#if LJ_HASPROFILE
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, PC
  //|  bl extern lj_dispatch_profile	// (lua_State *L, const BCIns *pc)
  //|  // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
  //|  ldr BASE, L->base
  //|  sub PC, PC, #4
  //|  b ->cont_nop
  dasm_put(Dst, 2621, Dt1(->base), Dt1(->base));
#line 1918 "vm_arm64.dasc"
#endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Trace exit handler -------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro savex_, a, b
  //|  stp d..a, d..b, [sp, #a*8]
  //|  stp x..a, x..b, [sp, #32*8+a*8]
  //|.endmacro
  //|
  //|->vm_exit_handler:
  //|.if JIT
  //|  sub     sp, sp, #(64*8)
  //|  savex_, 0, 1
  //|  savex_, 2, 3
  //|  savex_, 4, 5
  //|  savex_, 6, 7
  //|  savex_, 8, 9
  //|  savex_, 10, 11
  //|  savex_, 12, 13
  //|  savex_, 14, 15
  //|  savex_, 16, 17
  //|  savex_, 18, 19
  //|  savex_, 20, 21
  //|  savex_, 22, 23
  //|  savex_, 24, 25
  //|  savex_, 26, 27
  //|  savex_, 28, 29
  //|  stp d30, d31, [sp, #30*8]
  //|  ldr CARG1, [sp, #64*8]	// Load original value of lr.
  //|   add CARG3, sp, #64*8	// Recompute original value of sp.
  //|    mv_vmstate CARG4w, EXIT
  //|   stp xzr, CARG3, [sp, #62*8]	// Store 0/sp in RID_LR/RID_SP.
  //|  sub CARG1, CARG1, lr
  //|   ldr L, GL->cur_L
  //|  lsr CARG1, CARG1, #2
  //|   ldr BASE, GL->jit_base
  //|  sub CARG1, CARG1, #2
  //|   ldr CARG2w, [lr]		// Load trace number.
  //|    st_vmstate CARG4w
  //|.if ENDIAN_BE
  //|   rev32 CARG2, CARG2
  //|.endif
  //|   str BASE, L->base
  //|  ubfx CARG2w, CARG2w, #5, #16
  //|  str CARG1w, [GL, #GL_J(exitno)]
  //|   str CARG2w, [GL, #GL_J(parent)]
  //|   str L, [GL, #GL_J(L)]
  //|  str xzr, GL->jit_base
  //|  add CARG1, GL, #GG_G2J
  //|  mov CARG2, sp
  //|  bl extern lj_trace_exit		// (jit_State *J, ExitState *ex)
  //|  // Returns MULTRES (unscaled) or negated error code.
  //|  ldr CARG2, L->cframe
  //|   ldr BASE, L->base
  //|  and sp, CARG2, #CFRAME_RAWMASK
  //|   ldr PC, SAVE_PC			// Get SAVE_PC.
  //|  str L, SAVE_L			// Set SAVE_L (on-trace resume/yield).
  //|  b >1
  //|.endif
  //|
  //|->vm_exit_interp:
  //|  // CARG1 = MULTRES or negated error code, BASE, PC and GL set.
  //|.if JIT
  //|  ldr L, SAVE_L
  //|1:
  //|  cmp CARG1w, #0
  //|  blt >9				// Check for error from exit.
  //|   lsl RC, CARG1, #3
  //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
  //|    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
  //|    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
  //|    movn TISNIL, #0
  //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
  //|   str RCw, SAVE_MULTRES
  dasm_put(Dst, 2633, LJ_VMST_EXIT, Dt2(->cur_L), Dt2(->jit_base), Dt2(->vmstate), Dt1(->base), GL_J(exitno), GL_J(parent), GL_J(L), Dt2(->jit_base), GG_G2J, Dt1(->cframe), Dt1(->base), (unsigned int)(CFRAME_RAWMASK), (unsigned int)((unsigned long long)(CFRAME_RAWMASK)>>32), (LJ_TISNUM>>1)&0xffff, (LJ_TISNUM>>1)&0xffff, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 1994 "vm_arm64.dasc"
  //|   str BASE, L->base
  //|  ldr CARG2, LFUNC:CARG2->pc
  //|   str xzr, GL->jit_base
  //|    mv_vmstate CARG4w, INTERP
  //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
  //|  // Modified copy of ins_next which handles function header dispatch, too.
  //|  ldrb RBw, [PC, # OFS_OP]
  //|   ldr INSw, [PC], #4
  //|    st_vmstate CARG4w
  //|  cmp RBw, #BC_FUNCC+2		// Fast function?
  //|   add TMP1, GL, INS, uxtb #3
  //|  bhs >4
  //|2:
  //|  cmp RBw, #BC_FUNCF			// Function header?
  //|  add TMP0, GL, RB, uxtb #3
  //|  ldr RB, [TMP0, #GG_G2DISP]
  //|   decode_RA RA, INS
  //|   lsr TMP0, INS, #16
  //|   csel RC, TMP0, RC, lo
  //|   blo >5
  //|   ldr CARG3, [BASE, FRAME_FUNC]
  //|   sub RC, RC, #8
  //|   add RA, BASE, RA, lsl #3	// Yes: RA = BASE+framesize*8, RC = nargs*8
  //|   and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|5:
  //|  br RB
  //|
  //|4:  // Check frame below fast function.
  //|  ldr CARG1, [BASE, FRAME_PC]
  //|  ands CARG2, CARG1, #FRAME_TYPE
  //|  bne <2			// Trace stitching continuation?
  //|  // Otherwise set KBASE for Lua function below fast function.
  //|  ldr CARG3w, [CARG1, #-4]
  //|  decode_RA CARG1, CARG3
  //|  sub CARG2, BASE, CARG1, lsl #3
  //|  ldr LFUNC:CARG3, [CARG2, #-32]
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  ldr CARG3, LFUNC:CARG3->pc
  //|  ldr KBASE, [CARG3, #PC2PROTO(k)]
  //|  b <2
  //|
  //|9:  // Rethrow error from the right C frame.
  //|  neg CARG2, CARG1
  dasm_put(Dst, 2723, Dt1(->base), Dt7(->pc), Dt2(->jit_base), LJ_VMST_INTERP, PC2PROTO(k), Dt2(->vmstate), BC_FUNCC+2, BC_FUNCF, GG_G2DISP, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), PC2PROTO(k));
#line 2037 "vm_arm64.dasc"
  //|  mov CARG1, L
  //|  bl extern lj_err_throw		// (lua_State *L, int errcode)
  //|.endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Math helper functions ----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|  // int lj_vm_modi(int dividend, int divisor);
  //|->vm_modi:
  //|    eor CARG4w, CARG1w, CARG2w
  //|    cmp CARG4w, #0
  //|  eor CARG3w, CARG1w, CARG1w, asr #31
  //|   eor CARG4w, CARG2w, CARG2w, asr #31
  //|  sub CARG3w, CARG3w, CARG1w, asr #31
  //|   sub CARG4w, CARG4w, CARG2w, asr #31
  //|  udiv CARG1w, CARG3w, CARG4w
  //|  msub CARG1w, CARG1w, CARG4w, CARG3w
  //|    ccmp CARG1w, #0, #4, mi
  //|    sub CARG3w, CARG1w, CARG4w
  //|    csel CARG1w, CARG1w, CARG3w, eq
  //|  eor CARG3w, CARG1w, CARG2w
  //|  cmp CARG3w, #0
  //|  cneg CARG1w, CARG1w, mi
  //|  ret
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Miscellaneous functions --------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-----------------------------------------------------------------------
  //|//-- FFI helper functions -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// Handler for callback functions.
  //|// Saveregs already performed. Callback slot number in [sp], g in r12.
  //|->vm_ffi_callback:
  //|.if FFI
  //|.type CTSTATE, CTState, PC
#define DtF(_V) (int)(ptrdiff_t)&(((CTState *)0)_V)
#line 2076 "vm_arm64.dasc"
  //|  saveregs
  //|  ldr CTSTATE, GL:x10->ctype_state
  //|  mov GL, x10
  //|    add x10, sp, # CFRAME_SPACE
  //|  str w9, CTSTATE->cb.slot
  //|  stp x0, x1, CTSTATE->cb.gpr[0]
  //|   stp d0, d1, CTSTATE->cb.fpr[0]
  //|  stp x2, x3, CTSTATE->cb.gpr[2]
  //|   stp d2, d3, CTSTATE->cb.fpr[2]
  //|  stp x4, x5, CTSTATE->cb.gpr[4]
  //|   stp d4, d5, CTSTATE->cb.fpr[4]
  //|  stp x6, x7, CTSTATE->cb.gpr[6]
  //|   stp d6, d7, CTSTATE->cb.fpr[6]
  //|    str x10, CTSTATE->cb.stack
  //|  mov CARG1, CTSTATE
  //|   str CTSTATE, SAVE_PC		// Any value outside of bytecode is ok.
  //|  mov CARG2, sp
  //|  bl extern lj_ccallback_enter	// (CTState *cts, void *cf)
  //|  // Returns lua_State *.
  //|  ldp BASE, RC, L:CRET1->base
  //|   movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
  //|   movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
  //|   movn TISNIL, #0
  //|   mov L, CRET1
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  sub RC, RC, BASE
  //|   st_vmstate ST_INTERP
  //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
  //|  ins_callt
  dasm_put(Dst, 2781, Dt2(->ctype_state), DtF(->cb.slot), DtF(->cb.gpr[0]), DtF(->cb.fpr[0]), DtF(->cb.gpr[2]), DtF(->cb.fpr[2]), DtF(->cb.gpr[4]), DtF(->cb.fpr[4]), DtF(->cb.gpr[6]), DtF(->cb.fpr[6]), DtF(->cb.stack), Dt1(->base), (LJ_TISNUM>>1)&0xffff, (LJ_TISNUM>>1)&0xffff, Dt2(->vmstate), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP);
#line 2105 "vm_arm64.dasc"
  //|.endif
  //|
  //|->cont_ffi_callback:			// Return from FFI callback.
  //|.if FFI
  //|  ldr CTSTATE, GL->ctype_state
  //|   stp BASE, CARG4, L->base
  //|  str L, CTSTATE->L
  //|  mov CARG1, CTSTATE
  //|  mov CARG2, RA
  //|  bl extern lj_ccallback_leave       // (CTState *cts, TValue *o)
  //|  ldp x0, x1, CTSTATE->cb.gpr[0]
  //|   ldp d0, d1, CTSTATE->cb.fpr[0]
  //|  b ->vm_leave_unw
  //|.endif
  //|
  //|->vm_ffi_call:			// Call C function via FFI.
  //|  // Caveat: needs special frame unwinding, see below.
  //|.if FFI
  //|  .type CCSTATE, CCallState, x19
#define Dt10(_V) (int)(ptrdiff_t)&(((CCallState *)0)_V)
#line 2124 "vm_arm64.dasc"
  //|  stp fp, lr, [sp, #-32]!
  //|  add fp, sp, #0
  //|  str CCSTATE, [sp, #16]
  //|  mov CCSTATE, x0
  //|  ldr TMP0w, CCSTATE:x0->spadj
  //|   ldrb TMP1w, CCSTATE->nsp
  //|    add TMP2, CCSTATE, #offsetof(CCallState, stack)
  //|   subs TMP1, TMP1, #1
  //|    ldr TMP3, CCSTATE->func
  //|  sub sp, fp, TMP0
  //|   bmi >2
  //|1:  // Copy stack slots
  //|  ldr TMP0, [TMP2, TMP1, lsl #3]
  //|  str TMP0, [sp, TMP1, lsl #3]
  //|  subs TMP1, TMP1, #1
  //|  bpl <1
  //|2:
  //|  ldp x0, x1, CCSTATE->gpr[0]
  //|   ldp d0, d1, CCSTATE->fpr[0]
  //|  ldp x2, x3, CCSTATE->gpr[2]
  //|   ldp d2, d3, CCSTATE->fpr[2]
  //|  ldp x4, x5, CCSTATE->gpr[4]
  //|   ldp d4, d5, CCSTATE->fpr[4]
  dasm_put(Dst, 2864, Dt2(->ctype_state), Dt1(->base), DtF(->L), DtF(->cb.gpr[0]), DtF(->cb.fpr[0]), Dt10(->spadj), Dt10(->nsp), offsetof(CCallState, stack), Dt10(->func), Dt10(->gpr[0]), Dt10(->fpr[0]), Dt10(->gpr[2]), Dt10(->fpr[2]), Dt10(->gpr[4]));
#line 2147 "vm_arm64.dasc"
  //|  ldp x6, x7, CCSTATE->gpr[6]
  //|   ldp d6, d7, CCSTATE->fpr[6]
  //|  ldr x8, CCSTATE->retp
  //|  blr TMP3
  //|  mov sp, fp
  //|  stp x0, x1, CCSTATE->gpr[0]
  //|   stp d0, d1, CCSTATE->fpr[0]
  //|   stp d2, d3, CCSTATE->fpr[2]
  //|  ldr CCSTATE, [sp, #16]
  //|  ldp fp, lr, [sp], #32
  //|  ret
  //|.endif
  //|// Note: vm_ffi_call must be the last function in this object file!
  //|
  //|//-----------------------------------------------------------------------
  dasm_put(Dst, 2918, Dt10(->fpr[4]), Dt10(->gpr[6]), Dt10(->fpr[6]), Dt10(->retp), Dt10(->gpr[0]), Dt10(->fpr[0]), Dt10(->fpr[2]));
#line 2162 "vm_arm64.dasc"
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  //|=>defop:
  dasm_put(Dst, 2938, defop);
#line 2169 "vm_arm64.dasc"

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    //|  // RA = src1, RC = src2, JMP with RC = target
    //|  ldr CARG1, [BASE, RA, lsl #3]
    //|    ldrh RBw, [PC, # OFS_RD]
    //|   ldr CARG2, [BASE, RC, lsl #3]
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|    sub RB, RB, #0x20000
    //|  checkint CARG1, >3
    //|   checkint CARG2, >4
    //|  cmp CARG1w, CARG2w
    dasm_put(Dst, 2940);
#line 2187 "vm_arm64.dasc"
    if (op == BC_ISLT) {
      //|  csel PC, RB, PC, lt
      dasm_put(Dst, 2954);
#line 2189 "vm_arm64.dasc"
    } else if (op == BC_ISGE) {
      //|  csel PC, RB, PC, ge
      dasm_put(Dst, 2956);
#line 2191 "vm_arm64.dasc"
    } else if (op == BC_ISLE) {
      //|  csel PC, RB, PC, le
      dasm_put(Dst, 2958);
#line 2193 "vm_arm64.dasc"
    } else {
      //|  csel PC, RB, PC, gt
      dasm_put(Dst, 2960);
#line 2195 "vm_arm64.dasc"
    }
    //|1:
    //|  ins_next
    //|
    //|3:  // RA not int.
    //|    ldr FARG1, [BASE, RA, lsl #3]
    //|  blo ->vmeta_comp
    //|    ldr FARG2, [BASE, RC, lsl #3]
    //|   cmp TISNUMhi, CARG2, lsr #32
    //|   bhi >5
    //|   bne ->vmeta_comp
    //|  // RA number, RC int.
    //|  scvtf FARG2, CARG2w
    //|  b >5
    //|
    //|4:  // RA int, RC not int
    //|    ldr FARG2, [BASE, RC, lsl #3]
    //|   blo ->vmeta_comp
    //|  // RA int, RC number.
    //|  scvtf FARG1, CARG1w
    //|
    //|5:  // RA number, RC number
    //|  fcmp FARG1, FARG2
    //|  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    dasm_put(Dst, 2962, GG_G2DISP);
#line 2219 "vm_arm64.dasc"
    if (op == BC_ISLT) {
      //|  csel PC, RB, PC, lo
      dasm_put(Dst, 2991);
#line 2221 "vm_arm64.dasc"
    } else if (op == BC_ISGE) {
      //|  csel PC, RB, PC, hs
      dasm_put(Dst, 2993);
#line 2223 "vm_arm64.dasc"
    } else if (op == BC_ISLE) {
      //|  csel PC, RB, PC, ls
      dasm_put(Dst, 2995);
#line 2225 "vm_arm64.dasc"
    } else {
      //|  csel PC, RB, PC, hi
      dasm_put(Dst, 2997);
#line 2227 "vm_arm64.dasc"
    }
    //|  b <1
    dasm_put(Dst, 2999);
#line 2229 "vm_arm64.dasc"
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    //|  // RA = src1, RC = src2, JMP with RC = target
    //|  ldr CARG1, [BASE, RA, lsl #3]
    //|   add RC, BASE, RC, lsl #3
    //|    ldrh RBw, [PC, # OFS_RD]
    //|   ldr CARG3, [RC]
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|    sub RB, RB, #0x20000
    //|  asr ITYPE, CARG3, #47
    //|  cmn ITYPE, #-LJ_TISNUM
    dasm_put(Dst, 3002, -LJ_TISNUM);
#line 2243 "vm_arm64.dasc"
    if (vk) {
      //|  bls ->BC_ISEQN_Z
      dasm_put(Dst, 3013);
#line 2245 "vm_arm64.dasc"
    } else {
      //|  bls ->BC_ISNEN_Z
      dasm_put(Dst, 3016);
#line 2247 "vm_arm64.dasc"
    }
    //|  // RC is not a number.
    //|   asr TMP0, CARG1, #47
    //|.if FFI
    //|  // Check if RC or RA is a cdata.
    //|  cmn ITYPE, #-LJ_TCDATA
    //|   ccmn TMP0, #-LJ_TCDATA, #4, ne
    //|  beq ->vmeta_equal_cd
    //|.endif
    //|  cmp CARG1, CARG3
    //|  bne >2
    //|  // Tag and value are equal.
    dasm_put(Dst, 3019, -LJ_TCDATA, -LJ_TCDATA);
#line 2259 "vm_arm64.dasc"
    if (vk) {
      //|->BC_ISEQV_Z:
      //|  mov PC, RB			// Perform branch.
      dasm_put(Dst, 3030);
#line 2262 "vm_arm64.dasc"
    }
    //|1:
    //|  ins_next
    //|
    //|2:  // Check if the tags are the same and it's a table or userdata.
    //|  cmp ITYPE, TMP0
    //|  ccmn ITYPE, #-LJ_TISTABUD, #2, eq
    dasm_put(Dst, 3033, GG_G2DISP, -LJ_TISTABUD);
#line 2269 "vm_arm64.dasc"
    if (vk) {
      //|  bhi <1
      dasm_put(Dst, 3046);
#line 2271 "vm_arm64.dasc"
    } else {
      //|  bhi ->BC_ISEQV_Z		// Reuse code from opposite instruction.
      dasm_put(Dst, 3049);
#line 2273 "vm_arm64.dasc"
    }
    //|  // Different tables or userdatas. Need to check __eq metamethod.
    //|  // Field metatable must be at same offset for GCtab and GCudata!
    //|  and TAB:CARG2, CARG1, #LJ_GCVMASK
    //|  ldr TAB:TMP2, TAB:CARG2->metatable
    dasm_put(Dst, 3052, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->metatable));
#line 2278 "vm_arm64.dasc"
    if (vk) {
      //|  cbz TAB:TMP2, <1		// No metatable?
      //|  ldrb TMP1w, TAB:TMP2->nomm
      //|   mov CARG4, #0			// ne = 0
      //|  tbnz TMP1w, #MM_eq, <1		// 'no __eq' flag set: done.
      dasm_put(Dst, 3057, Dt6(->nomm), MM_eq);
#line 2283 "vm_arm64.dasc"
    } else {
      //|  cbz TAB:TMP2, ->BC_ISEQV_Z	// No metatable?
      //|  ldrb TMP1w, TAB:TMP2->nomm
      //|   mov CARG4, #1			// ne = 1.
      //|  tbnz TMP1w, #MM_eq, ->BC_ISEQV_Z	// 'no __eq' flag set: done.
      dasm_put(Dst, 3066, Dt6(->nomm), MM_eq);
#line 2288 "vm_arm64.dasc"
    }
    //|  b ->vmeta_equal
    dasm_put(Dst, 3075);
#line 2290 "vm_arm64.dasc"
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    //|  // RA = src, RC = str_const (~), JMP with RC = target
    //|  ldr CARG1, [BASE, RA, lsl #3]
    //|   mvn RC, RC
    //|    ldrh RBw, [PC, # OFS_RD]
    //|   ldr CARG2, [KBASE, RC, lsl #3]
    //|    add PC, PC, #4
    //|   movn TMP0, #~LJ_TSTR
    //|.if FFI
    //|  asr ITYPE, CARG1, #47
    //|.endif
    //|    add RB, PC, RB, lsl #2
    //|   add CARG2, CARG2, TMP0, lsl #47
    //|    sub RB, RB, #0x20000
    //|.if FFI
    //|  cmn ITYPE, #-LJ_TCDATA
    //|  beq ->vmeta_equal_cd
    //|.endif
    //|  cmp CARG1, CARG2
    dasm_put(Dst, 3078, ~LJ_TSTR, -LJ_TCDATA);
#line 2312 "vm_arm64.dasc"
    if (vk) {
      //|  csel PC, RB, PC, eq
      dasm_put(Dst, 3095);
#line 2314 "vm_arm64.dasc"
    } else {
      //|  csel PC, RB, PC, ne
      dasm_put(Dst, 3097);
#line 2316 "vm_arm64.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 3099, GG_G2DISP);
#line 2318 "vm_arm64.dasc"
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    //|  // RA = src, RC = num_const (~), JMP with RC = target
    //|  ldr CARG1, [BASE, RA, lsl #3]
    //|   add RC, KBASE, RC, lsl #3
    //|    ldrh RBw, [PC, # OFS_RD]
    //|   ldr CARG3, [RC]
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|    sub RB, RB, #0x20000
    dasm_put(Dst, 3107);
#line 2330 "vm_arm64.dasc"
    if (vk) {
      //|->BC_ISEQN_Z:
      dasm_put(Dst, 3115);
#line 2332 "vm_arm64.dasc"
    } else {
      //|->BC_ISNEN_Z:
      dasm_put(Dst, 3117);
#line 2334 "vm_arm64.dasc"
    }
    //|  checkint CARG1, >4
    //|   checkint CARG3, >6
    //|  cmp CARG1w, CARG3w
    //|1:
    dasm_put(Dst, 3119);
#line 2339 "vm_arm64.dasc"
    if (vk) {
      //|  csel PC, RB, PC, eq
      //|2:
      dasm_put(Dst, 3128);
#line 2342 "vm_arm64.dasc"
    } else {
      //|2:
      //|  csel PC, RB, PC, ne
      dasm_put(Dst, 3131);
#line 2345 "vm_arm64.dasc"
    }
    //|3:
    //|  ins_next
    //|
    //|4:  // RA not int.
    //|.if FFI
    //|  blo >7
    //|.else
    //|  blo <2
    //|.endif
    //|    ldr FARG1, [BASE, RA, lsl #3]
    //|    ldr FARG2, [RC]
    //|   cmp TISNUMhi, CARG3, lsr #32
    //|   bne >5
    //|  // RA number, RC int.
    //|  scvtf FARG2, CARG3w
    //|5:
    //|  // RA number, RC number.
    //|  fcmp FARG1, FARG2
    //|  b <1
    //|
    //|6:  // RA int, RC number
    //|  ldr FARG2, [RC]
    //|  scvtf FARG1, CARG1w
    //|  fcmp FARG1, FARG2
    //|  b <1
    //|
    //|.if FFI
    //|7:
    //|  asr ITYPE, CARG1, #47
    //|  cmn ITYPE, #-LJ_TCDATA
    //|  bne <2
    //|  b ->vmeta_equal_cd
    //|.endif
    dasm_put(Dst, 3134, GG_G2DISP, -LJ_TCDATA);
#line 2379 "vm_arm64.dasc"
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    //|  // RA = src, RC = primitive_type (~), JMP with RC = target
    //|  ldr TMP0, [BASE, RA, lsl #3]
    //|   ldrh RBw, [PC, # OFS_RD]
    //|   add PC, PC, #4
    //|  add RC, RC, #1
    //|   add RB, PC, RB, lsl #2
    //|.if FFI
    //|  asr ITYPE, TMP0, #47
    //|  cmn ITYPE, #-LJ_TCDATA
    //|  beq ->vmeta_equal_cd
    //|  cmn RC, ITYPE
    //|.else
    //|  cmn RC, TMP0, asr #47
    //|.endif
    //|   sub RB, RB, #0x20000
    dasm_put(Dst, 3170, -LJ_TCDATA);
#line 2398 "vm_arm64.dasc"
    if (vk) {
      //|  csel PC, RB, PC, eq
      dasm_put(Dst, 3183);
#line 2400 "vm_arm64.dasc"
    } else {
      //|  csel PC, RB, PC, ne
      dasm_put(Dst, 3185);
#line 2402 "vm_arm64.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 3187, GG_G2DISP);
#line 2404 "vm_arm64.dasc"
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    //|  // RA = dst or unused, RC = src, JMP with RC = target
    //|   ldrh RBw, [PC, # OFS_RD]
    //|  ldr TMP0, [BASE, RC, lsl #3]
    //|   add PC, PC, #4
    //|  mov_false TMP1
    //|   add RB, PC, RB, lsl #2
    //|  cmp TMP0, TMP1
    //|   sub RB, RB, #0x20000
    dasm_put(Dst, 3195);
#line 2417 "vm_arm64.dasc"
    if (op == BC_ISTC || op == BC_IST) {
      if (op == BC_ISTC) {
	//|  csel RA, RA, RC, lo
	dasm_put(Dst, 3203);
#line 2420 "vm_arm64.dasc"
      }
      //|  csel PC, RB, PC, lo
      dasm_put(Dst, 3205);
#line 2422 "vm_arm64.dasc"
    } else {
      if (op == BC_ISFC) {
	//|  csel RA, RA, RC, hs
	dasm_put(Dst, 3207);
#line 2425 "vm_arm64.dasc"
      }
      //|  csel PC, RB, PC, hs
      dasm_put(Dst, 3209);
#line 2427 "vm_arm64.dasc"
    }
    if (op == BC_ISTC || op == BC_ISFC) {
      //|  str TMP0, [BASE, RA, lsl #3]
      dasm_put(Dst, 3211);
#line 2430 "vm_arm64.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 3213, GG_G2DISP);
#line 2432 "vm_arm64.dasc"
    break;

  case BC_ISTYPE:
    //|  // RA = src, RC = -type
    //|  ldr TMP0, [BASE, RA, lsl #3]
    //|  cmn RC, TMP0, asr #47
    //|  bne ->vmeta_istype
    //|  ins_next
    dasm_put(Dst, 3221, GG_G2DISP);
#line 2440 "vm_arm64.dasc"
    break;
  case BC_ISNUM:
    //|  // RA = src, RC = -(TISNUM-1)
    //|  ldr TMP0, [BASE, RA]
    //|  checknum TMP0, ->vmeta_istype
    //|  ins_next
    dasm_put(Dst, 3233, GG_G2DISP);
#line 2446 "vm_arm64.dasc"
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    //|  // RA = dst, RC = src
    //|  ldr TMP0, [BASE, RC, lsl #3]
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3245, GG_G2DISP);
#line 2455 "vm_arm64.dasc"
    break;
  case BC_NOT:
    //|  // RA = dst, RC = src
    //|  ldr TMP0, [BASE, RC, lsl #3]
    //|   mov_false TMP1
    //|   mov_true TMP2
    //|  cmp TMP0, TMP1
    //|  csel TMP0, TMP1, TMP2, lo
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3255, GG_G2DISP);
#line 2465 "vm_arm64.dasc"
    break;
  case BC_UNM:
    //|  // RA = dst, RC = src
    //|  ldr TMP0, [BASE, RC, lsl #3]
    //|  asr ITYPE, TMP0, #47
    //|  cmn ITYPE, #-LJ_TISNUM
    //|  bhi ->vmeta_unm
    //|  eor TMP0, TMP0, #U64x(80000000,00000000)
    //|  bne >5
    //|  negs TMP0w, TMP0w
    //|   movz CARG3, #0x41e0, lsl #48	// 2^31.
    //|   add TMP0, TMP0, TISNUM
    //|  csel TMP0, TMP0, CARG3, vc
    //|5:
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3269, -LJ_TISNUM, (unsigned int)(U64x(80000000,00000000)), (unsigned int)((unsigned long long)(U64x(80000000,00000000))>>32), GG_G2DISP);
#line 2481 "vm_arm64.dasc"
    break;
  case BC_LEN:
    //|  // RA = dst, RC = src
    //|  ldr CARG1, [BASE, RC, lsl #3]
    //|  asr ITYPE, CARG1, #47
    //|  cmn ITYPE, #-LJ_TSTR
    //|   and CARG1, CARG1, #LJ_GCVMASK
    //|  bne >2
    //|  ldr CARG1w, STR:CARG1->len
    //|1:
    //|  add CARG1, CARG1, TISNUM
    //|  str CARG1, [BASE, RA, lsl #3]
    //|  ins_next
    //|
    //|2:
    //|  cmn ITYPE, #-LJ_TTAB
    //|  bne ->vmeta_len
    dasm_put(Dst, 3293, -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt5(->len), GG_G2DISP, -LJ_TTAB);
#line 2498 "vm_arm64.dasc"
#if LJ_52
    //|  ldr TAB:CARG2, TAB:CARG1->metatable
    //|  cbnz TAB:CARG2, >9
    //|3:
    dasm_put(Dst, 3319, Dt6(->metatable));
#line 2502 "vm_arm64.dasc"
#endif
    //|->BC_LEN_Z:
    //|  bl extern lj_tab_len		// (GCtab *t)
    //|  // Returns uint32_t (but less than 2^31).
    //|  b <1
    //|
    dasm_put(Dst, 3325);
#line 2508 "vm_arm64.dasc"
#if LJ_52
    //|9:
    //|  ldrb TMP1w, TAB:CARG2->nomm
    //|  tbnz TMP1w, #MM_len, <3		// 'no __len' flag set: done.
    //|  b ->vmeta_len
    dasm_put(Dst, 3331, Dt6(->nomm), MM_len);
#line 2513 "vm_arm64.dasc"
#endif
    break;

  /* -- Binary ops -------------------------------------------------------- */

    //|.macro ins_arithcheck_int, target
    //|  checkint CARG1, target
    //|  checkint CARG2, target
    //|.endmacro
    //|
    //|.macro ins_arithcheck_num, target
    //|  checknum CARG1, target
    //|  checknum CARG2, target
    //|.endmacro
    //|
    //|.macro ins_arithcheck_nzdiv, target
    //|  cbz CARG2w, target
    //|.endmacro
    //|
    //|.macro ins_arithhead
    //||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    //||if (vk == 1) {
    //|   and RC, RC, #255
    //|    decode_RB RB, INS
    //||} else {
    //|   decode_RB RB, INS
    //|    and RC, RC, #255
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithload, reg1, reg2
    //|  // RA = dst, RB = src1, RC = src2 | num_const
    //||switch (vk) {
    //||case 0:
    //|   ldr reg1, [BASE, RB, lsl #3]
    //|    ldr reg2, [KBASE, RC, lsl #3]
    //||  break;
    //||case 1:
    //|   ldr reg1, [KBASE, RC, lsl #3]
    //|    ldr reg2, [BASE, RB, lsl #3]
    //||  break;
    //||default:
    //|   ldr reg1, [BASE, RB, lsl #3]
    //|    ldr reg2, [BASE, RC, lsl #3]
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithfallback, ins
    //||switch (vk) {
    //||case 0:
    //|   ins ->vmeta_arith_vn
    //||  break;
    //||case 1:
    //|   ins ->vmeta_arith_nv
    //||  break;
    //||default:
    //|   ins ->vmeta_arith_vv
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithmod, res, reg1, reg2
    //|  fdiv d2, reg1, reg2
    //|  frintm d2, d2
    //|  fmsub res, d2, reg2, reg1
    //|.endmacro
    //|
    //|.macro ins_arithdn, intins, fpins
    //|  ins_arithhead
    //|  ins_arithload CARG1, CARG2
    //|  ins_arithcheck_int >5
    //|.if "intins" == "smull"
    //|  smull CARG1, CARG1w, CARG2w
    //|  cmp CARG1, CARG1, sxtw
    //|   mov CARG1w, CARG1w
    //|  ins_arithfallback bne
    //|.elif "intins" == "ins_arithmodi"
    //|  ins_arithfallback ins_arithcheck_nzdiv
    //|  bl ->vm_modi
    //|.else
    //|  intins CARG1w, CARG1w, CARG2w
    //|  ins_arithfallback bvs
    //|.endif
    //|  add CARG1, CARG1, TISNUM
    //|  str CARG1, [BASE, RA, lsl #3]
    //|4:
    //|  ins_next
    //|
    //|5:  // FP variant.
    //|  ins_arithload FARG1, FARG2
    //|  ins_arithfallback ins_arithcheck_num
    //|  fpins FARG1, FARG1, FARG2
    //|  str FARG1, [BASE, RA, lsl #3]
    //|  b <4
    //|.endmacro
    //|
    //|.macro ins_arithfp, fpins
    //|  ins_arithhead
    //|  ins_arithload CARG1, CARG2
    //|  ins_arithload FARG1, FARG2
    //|  ins_arithfallback ins_arithcheck_num
    //|.if "fpins" == "fpow"
    //|  bl extern pow
    //|.else
    //|  fpins FARG1, FARG1, FARG2
    //|.endif
    //|  str FARG1, [BASE, RA, lsl #3]
    //|  ins_next
    //|.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    //|  ins_arithdn adds, fadd
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3340);
    } else {
    dasm_put(Dst, 3343);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3346);
      break;
    case 1:
    dasm_put(Dst, 3349);
      break;
    default:
    dasm_put(Dst, 3352);
      break;
    }
    dasm_put(Dst, 3355);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3363);
      break;
    case 1:
    dasm_put(Dst, 3366);
      break;
    default:
    dasm_put(Dst, 3369);
      break;
    }
    dasm_put(Dst, 3372, GG_G2DISP);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3384);
      break;
    case 1:
    dasm_put(Dst, 3387);
      break;
    default:
    dasm_put(Dst, 3390);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3393);
      break;
    case 1:
    dasm_put(Dst, 3400);
      break;
    default:
    dasm_put(Dst, 3407);
      break;
    }
    dasm_put(Dst, 3414);
#line 2626 "vm_arm64.dasc"
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    //|  ins_arithdn subs, fsub
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3419);
    } else {
    dasm_put(Dst, 3422);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3425);
      break;
    case 1:
    dasm_put(Dst, 3428);
      break;
    default:
    dasm_put(Dst, 3431);
      break;
    }
    dasm_put(Dst, 3434);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3442);
      break;
    case 1:
    dasm_put(Dst, 3445);
      break;
    default:
    dasm_put(Dst, 3448);
      break;
    }
    dasm_put(Dst, 3451, GG_G2DISP);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3463);
      break;
    case 1:
    dasm_put(Dst, 3466);
      break;
    default:
    dasm_put(Dst, 3469);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3472);
      break;
    case 1:
    dasm_put(Dst, 3479);
      break;
    default:
    dasm_put(Dst, 3486);
      break;
    }
    dasm_put(Dst, 3493);
#line 2629 "vm_arm64.dasc"
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    //|  ins_arithdn smull, fmul
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3498);
    } else {
    dasm_put(Dst, 3501);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3504);
      break;
    case 1:
    dasm_put(Dst, 3507);
      break;
    default:
    dasm_put(Dst, 3510);
      break;
    }
    dasm_put(Dst, 3513);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3523);
      break;
    case 1:
    dasm_put(Dst, 3526);
      break;
    default:
    dasm_put(Dst, 3529);
      break;
    }
    dasm_put(Dst, 3532, GG_G2DISP);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3544);
      break;
    case 1:
    dasm_put(Dst, 3547);
      break;
    default:
    dasm_put(Dst, 3550);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3553);
      break;
    case 1:
    dasm_put(Dst, 3560);
      break;
    default:
    dasm_put(Dst, 3567);
      break;
    }
    dasm_put(Dst, 3574);
#line 2632 "vm_arm64.dasc"
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    //|  ins_arithfp fdiv
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3579);
    } else {
    dasm_put(Dst, 3582);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3585);
      break;
    case 1:
    dasm_put(Dst, 3588);
      break;
    default:
    dasm_put(Dst, 3591);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3594);
      break;
    case 1:
    dasm_put(Dst, 3597);
      break;
    default:
    dasm_put(Dst, 3600);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3603);
      break;
    case 1:
    dasm_put(Dst, 3610);
      break;
    default:
    dasm_put(Dst, 3617);
      break;
    }
    dasm_put(Dst, 3624, GG_G2DISP);
#line 2635 "vm_arm64.dasc"
    break;
  case BC_MODVN: case BC_MODNV: case BC_MODVV:
    //|  ins_arithdn ins_arithmodi, ins_arithmod
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3634);
    } else {
    dasm_put(Dst, 3637);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3640);
      break;
    case 1:
    dasm_put(Dst, 3643);
      break;
    default:
    dasm_put(Dst, 3646);
      break;
    }
    dasm_put(Dst, 3649);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3656);
      break;
    case 1:
    dasm_put(Dst, 3659);
      break;
    default:
    dasm_put(Dst, 3662);
      break;
    }
    dasm_put(Dst, 3665, GG_G2DISP);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3679);
      break;
    case 1:
    dasm_put(Dst, 3682);
      break;
    default:
    dasm_put(Dst, 3685);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3688);
      break;
    case 1:
    dasm_put(Dst, 3695);
      break;
    default:
    dasm_put(Dst, 3702);
      break;
    }
    dasm_put(Dst, 3709);
#line 2638 "vm_arm64.dasc"
    break;
  case BC_POW:
    //|  // NYI: (partial) integer arithmetic.
    //|  ins_arithfp fpow
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    if (vk == 1) {
    dasm_put(Dst, 3716);
    } else {
    dasm_put(Dst, 3719);
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3722);
      break;
    case 1:
    dasm_put(Dst, 3725);
      break;
    default:
    dasm_put(Dst, 3728);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3731);
      break;
    case 1:
    dasm_put(Dst, 3734);
      break;
    default:
    dasm_put(Dst, 3737);
      break;
    }
    switch (vk) {
    case 0:
    dasm_put(Dst, 3740);
      break;
    case 1:
    dasm_put(Dst, 3747);
      break;
    default:
    dasm_put(Dst, 3754);
      break;
    }
    dasm_put(Dst, 3761, GG_G2DISP);
#line 2642 "vm_arm64.dasc"
    break;

  case BC_CAT:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = src_start, RC = src_end
    //|   str BASE, L->base
    //|  sub CARG3, RC, RB
    //|  add CARG2, BASE, RC, lsl #3
    //|->BC_CAT_Z:
    //|  // RA = dst, CARG2 = top-1, CARG3 = left
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  bl extern lj_meta_cat		// (lua_State *L, TValue *top, int left)
    //|  // Returns NULL (finished) or TValue * (metamethod).
    //|  ldrb RBw, [PC, #-4+OFS_RB]
    //|   ldr BASE, L->base
    //|   cbnz CRET1, ->vmeta_binop
    //|  ldr TMP0, [BASE, RB, lsl #3]
    //|  str TMP0, [BASE, RA, lsl #3]	// Copy result to RA.
    //|  ins_next
    dasm_put(Dst, 3772, Dt1(->base), Dt1(->base), GG_G2DISP);
#line 2663 "vm_arm64.dasc"
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    //|  // RA = dst, RC = str_const (~)
    //|  mvn RC, RC
    //|  ldr TMP0, [KBASE, RC, lsl #3]
    //|   movn TMP1, #~LJ_TSTR
    //|  add TMP0, TMP0, TMP1, lsl #47
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3798, ~LJ_TSTR, GG_G2DISP);
#line 2675 "vm_arm64.dasc"
    break;
  case BC_KCDATA:
    //|.if FFI
    //|  // RA = dst, RC = cdata_const (~)
    //|  mvn RC, RC
    //|  ldr TMP0, [KBASE, RC, lsl #3]
    //|   movn TMP1, #~LJ_TCDATA
    //|  add TMP0, TMP0, TMP1, lsl #47
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    //|.endif
    dasm_put(Dst, 3812, ~LJ_TCDATA, GG_G2DISP);
#line 2686 "vm_arm64.dasc"
    break;
  case BC_KSHORT:
    //|  // RA = dst, RC = int16_literal
    //|  sxth RCw, RCw
    //|  add TMP0, RC, TISNUM
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3826, GG_G2DISP);
#line 2693 "vm_arm64.dasc"
    break;
  case BC_KNUM:
    //|  // RA = dst, RC = num_const
    //|  ldr TMP0, [KBASE, RC, lsl #3]
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3837, GG_G2DISP);
#line 2699 "vm_arm64.dasc"
    break;
  case BC_KPRI:
    //|  // RA = dst, RC = primitive_type (~)
    //|  mvn TMP0, RC, lsl #47
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3847, GG_G2DISP);
#line 2705 "vm_arm64.dasc"
    break;
  case BC_KNIL:
    //|  // RA = base, RC = end
    //|  add RA, BASE, RA, lsl #3
    //|   add RC, BASE, RC, lsl #3
    //|  str TISNIL, [RA], #8
    //|1:
    //|   cmp RA, RC
    //|  str TISNIL, [RA], #8
    //|   blt <1
    //|  ins_next_
    dasm_put(Dst, 3857, GG_G2DISP);
#line 2716 "vm_arm64.dasc"
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    //|  // RA = dst, RC = uvnum
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   add RC, RC, #offsetof(GCfuncL, uvptr)/8
    //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RC, lsl #3]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|  ldr TMP0, [CARG2]
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 3873, offsetof(GCfuncL, uvptr)/8, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), DtA(->v), GG_G2DISP);
#line 2730 "vm_arm64.dasc"
    break;
  case BC_USETV:
    //|  // RA = uvnum, RC = src
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)/8
    //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr UPVAL:CARG1, [LFUNC:CARG2, RA, lsl #3]
    //|   ldr CARG3, [BASE, RC, lsl #3]
    //|    ldr CARG2, UPVAL:CARG1->v
    //|  ldrb TMP2w, UPVAL:CARG1->marked
    //|  ldrb TMP0w, UPVAL:CARG1->closed
    //|    asr ITYPE, CARG3, #47
    //|   str CARG3, [CARG2]
    //|    add ITYPE, ITYPE, #-LJ_TISGCV
    //|  tst TMP2w, #LJ_GC_BLACK		// isblack(uv)
    //|  ccmp TMP0w, #0, #4, ne		// && uv->closed
    //|    ccmn ITYPE, #-(LJ_TNUMX - LJ_TISGCV), #0, ne	// && tvisgcv(v)
    //|  bhi >2
    //|1:
    //|  ins_next
    //|
    //|2:  // Check if new value is white.
    //|  and GCOBJ:CARG3, CARG3, #LJ_GCVMASK
    //|  ldrb TMP1w, GCOBJ:CARG3->gch.marked
    //|  tst TMP1w, #LJ_GC_WHITES		// iswhite(str)
    //|  beq <1
    //|  // Crossed a write barrier. Move the barrier forward.
    //|  mov CARG1, GL
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  b <1
    dasm_put(Dst, 3891, offsetof(GCfuncL, uvptr)/8, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), DtA(->v), DtA(->marked), DtA(->closed), -LJ_TISGCV, LJ_GC_BLACK, -(LJ_TNUMX - LJ_TISGCV), GG_G2DISP, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt4(->gch.marked), LJ_GC_WHITES);
#line 2760 "vm_arm64.dasc"
    break;
  case BC_USETS:
    //|  // RA = uvnum, RC = str_const (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)/8
    //|    mvn RC, RC
    //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr UPVAL:CARG1, [LFUNC:CARG2, RA, lsl #3]
    //|   ldr STR:CARG3, [KBASE, RC, lsl #3]
    //|   movn TMP0, #~LJ_TSTR
    //|    ldr CARG2, UPVAL:CARG1->v
    //|  ldrb TMP2w, UPVAL:CARG1->marked
    //|   add TMP0, STR:CARG3, TMP0, lsl #47
    //|    ldrb TMP1w, STR:CARG3->marked
    //|   str TMP0, [CARG2]
    //|  tbnz TMP2w, #2, >2		// isblack(uv)
    //|1:
    //|  ins_next
    //|
    //|2:  // Check if string is white and ensure upvalue is closed.
    //|  ldrb TMP0w, UPVAL:CARG1->closed
    //|    tst TMP1w, #LJ_GC_WHITES	// iswhite(str)
    //|  ccmp TMP0w, #0, #0, ne
    //|  beq <1
    //|  // Crossed a write barrier. Move the barrier forward.
    //|  mov CARG1, GL
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  b <1
    dasm_put(Dst, 3938, offsetof(GCfuncL, uvptr)/8, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), ~LJ_TSTR, DtA(->v), DtA(->marked), Dt5(->marked), GG_G2DISP, DtA(->closed), LJ_GC_WHITES);
#line 2788 "vm_arm64.dasc"
    break;
  case BC_USETN:
    //|  // RA = uvnum, RC = num_const
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)/8
    //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA, lsl #3]
    //|   ldr TMP0, [KBASE, RC, lsl #3]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   str TMP0, [CARG2]
    //|  ins_next
    dasm_put(Dst, 3980, offsetof(GCfuncL, uvptr)/8, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), DtA(->v), GG_G2DISP);
#line 2799 "vm_arm64.dasc"
    break;
  case BC_USETP:
    //|  // RA = uvnum, RC = primitive_type (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)/8
    //|  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA, lsl #3]
    //|   mvn TMP0, RC, lsl #47
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   str TMP0, [CARG2]
    //|  ins_next
    dasm_put(Dst, 3998, offsetof(GCfuncL, uvptr)/8, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), DtA(->v), GG_G2DISP);
#line 2810 "vm_arm64.dasc"
    break;

  case BC_UCLO:
    //|  // RA = level, RC = target
    //|  ldr CARG3, L->openupval
    //|   add RC, PC, RC, lsl #2
    //|    str BASE, L->base
    //|   sub PC, RC, #0x20000
    //|  cbz CARG3, >1
    //|  mov CARG1, L
    //|  add CARG2, BASE, RA, lsl #3
    //|  bl extern lj_func_closeuv	// (lua_State *L, TValue *level)
    //|  ldr BASE, L->base
    //|1:
    //|  ins_next
    dasm_put(Dst, 4016, Dt1(->openupval), Dt1(->base), Dt1(->base), GG_G2DISP);
#line 2825 "vm_arm64.dasc"
    break;

  case BC_FNEW:
    //|  // RA = dst, RC = proto_const (~) (holding function prototype)
    //|  mvn RC, RC
    //|   str BASE, L->base
    //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
    //|    str PC, SAVE_PC
    //|   ldr CARG2, [KBASE, RC, lsl #3]
    //|    mov CARG1, L
    //|  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
    //|  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    //|  bl extern lj_func_newL_gc
    //|  // Returns GCfuncL *.
    //|  ldr BASE, L->base
    //|   movn TMP0, #~LJ_TFUNC
    //|   add CRET1, CRET1, TMP0, lsl #47
    //|  str CRET1, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 4039, Dt1(->base), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt1(->base), ~LJ_TFUNC, GG_G2DISP);
#line 2844 "vm_arm64.dasc"
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    //|  // RA = dst, RC = (hbits|asize) | tab_const (~)
    //|  ldp CARG3, CARG4, GL->gc.total	// Assumes threshold follows total.
    //|   str BASE, L->base
    //|   str PC, SAVE_PC
    //|   mov CARG1, L
    //|  cmp CARG3, CARG4
    //|  bhs >5
    //|1:
    dasm_put(Dst, 4064, Dt2(->gc.total), Dt1(->base));
#line 2858 "vm_arm64.dasc"
    if (op == BC_TNEW) {
      //|  and CARG2, RC, #0x7ff
      //|   lsr CARG3, RC, #11
      //|  cmp CARG2, #0x7ff
      //|  mov TMP0, #0x801
      //|  csel CARG2, CARG2, TMP0, ne
      //|  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4075);
#line 2866 "vm_arm64.dasc"
    } else {
      //|  mvn RC, RC
      //|  ldr CARG2, [KBASE, RC, lsl #3]
      //|  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4083);
#line 2871 "vm_arm64.dasc"
    }
    //|  ldr BASE, L->base
    //|   movk CRET1, #(LJ_TTAB>>1)&0xffff, lsl #48
    //|  str CRET1, [BASE, RA, lsl #3]
    //|  ins_next
    //|
    //|5:
    //|  bl extern lj_gc_step_fixtop  // (lua_State *L)
    //|  mov CARG1, L
    //|  b <1
    dasm_put(Dst, 4088, Dt1(->base), (LJ_TTAB>>1)&0xffff, GG_G2DISP);
#line 2881 "vm_arm64.dasc"
    break;

  case BC_GGET:
    //|  // RA = dst, RC = str_const (~)
  case BC_GSET:
    //|  // RA = dst, RC = str_const (~)
    //|  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    //|   mvn RC, RC
    //|  and LFUNC:CARG1, CARG1, #LJ_GCVMASK
    //|  ldr TAB:CARG2, LFUNC:CARG1->env
    //|   ldr STR:RC, [KBASE, RC, lsl #3]
    dasm_put(Dst, 4107, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->env));
#line 2892 "vm_arm64.dasc"
    if (op == BC_GGET) {
      //|  b ->BC_TGETS_Z
      dasm_put(Dst, 4115);
#line 2894 "vm_arm64.dasc"
    } else {
      //|  b ->BC_TSETS_Z
      dasm_put(Dst, 4118);
#line 2896 "vm_arm64.dasc"
    }
    break;

  case BC_TGETV:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = table, RC = key
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|   ldr TMP1, [BASE, RC, lsl #3]
    //|  checktab CARG2, ->vmeta_tgetv
    //|  checkint TMP1, >9		// Integer key?
    //|  ldr CARG3, TAB:CARG2->array
    //|   ldr CARG1w, TAB:CARG2->asize
    //|  add CARG3, CARG3, TMP1, uxtw #3
    //|   cmp TMP1w, CARG1w		// In array part?
    //|   bhs ->vmeta_tgetv
    //|  ldr TMP0, [CARG3]
    //|  cmp TMP0, TISNIL
    //|  beq >5
    //|1:
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <1		// No metatable: done.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_index, <1	// 'no __index' flag set: done.
    //|  b ->vmeta_tgetv
    //|
    //|9:
    //|  asr ITYPE, TMP1, #47
    //|  cmn ITYPE, #-LJ_TSTR		// String key?
    //|  bne ->vmeta_tgetv
    //|   and STR:RC, TMP1, #LJ_GCVMASK
    //|  b ->BC_TGETS_Z
    dasm_put(Dst, 4121, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->asize), GG_G2DISP, Dt6(->metatable), Dt6(->nomm), MM_index, -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 2932 "vm_arm64.dasc"
    break;
  case BC_TGETS:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = table, RC = str_const (~)
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #3]
    //|  checktab CARG2, ->vmeta_tgets1
    //|->BC_TGETS_Z:
    //|  // TAB:CARG2 = GCtab *, STR:RC = GCstr *, RA = dst
    //|  ldr TMP1w, TAB:CARG2->hmask
    //|   ldr TMP2w, STR:RC->hash
    //|    ldr NODE:CARG3, TAB:CARG2->node
    //|  and TMP1w, TMP1w, TMP2w		// idx = str->hash & tab->hmask
    //|  add TMP1, TMP1, TMP1, lsl #1
    //|  movn CARG4, #~LJ_TSTR
    //|    add NODE:CARG3, NODE:CARG3, TMP1, lsl #3  // node = tab->node + idx*3*8
    //|  add CARG4, STR:RC, CARG4, lsl #47	// Tagged key to look for.
    //|1:
    //|  ldp TMP0, CARG1, NODE:CARG3->val
    //|   ldr NODE:CARG3, NODE:CARG3->next
    //|  cmp CARG1, CARG4
    //|  bne >4
    //|  cmp TMP0, TISNIL
    //|  beq >5
    //|3:
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    //|
    //|4:  // Follow hash chain.
    //|  cbnz NODE:CARG3, <1
    //|  // End of hash chain: key not found, nil result.
    //|   mov TMP0, TISNIL
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <3		// No metatable: done.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_index, <3	// 'no __index' flag set: done.
    //|  b ->vmeta_tgets
    dasm_put(Dst, 4179, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->hmask), Dt5(->hash), Dt6(->node), ~LJ_TSTR, DtB(->val), DtB(->next), GG_G2DISP, Dt6(->metatable), Dt6(->nomm), MM_index);
    dasm_put(Dst, 4239);
#line 2973 "vm_arm64.dasc"
    break;
  case BC_TGETB:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = table, RC = index
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|  checktab CARG2, ->vmeta_tgetb
    //|  ldr CARG3, TAB:CARG2->array
    //|   ldr CARG1w, TAB:CARG2->asize
    //|  add CARG3, CARG3, RC, lsl #3
    //|   cmp RCw, CARG1w			// In array part?
    //|   bhs ->vmeta_tgetb
    //|  ldr TMP0, [CARG3]
    //|  cmp TMP0, TISNIL
    //|  beq >5
    //|1:
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <1		// No metatable: done.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_index, <1	// 'no __index' flag set: done.
    //|  b ->vmeta_tgetb
    dasm_put(Dst, 4242, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->asize), GG_G2DISP, Dt6(->metatable), Dt6(->nomm), MM_index);
#line 2998 "vm_arm64.dasc"
    break;
  case BC_TGETR:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = table, RC = key
    //|  ldr CARG1, [BASE, RB, lsl #3]
    //|   ldr TMP1, [BASE, RC, lsl #3]
    //|  and TAB:CARG1, CARG1, #LJ_GCVMASK
    //|  ldr CARG3, TAB:CARG1->array
    //|   ldr TMP2w, TAB:CARG1->asize
    //|  add CARG3, CARG3, TMP1w, uxtw #3
    //|   cmp TMP1w, TMP2w		// In array part?
    //|   bhs ->vmeta_tgetr
    //|  ldr TMP0, [CARG3]
    //|->BC_TGETR_Z:
    //|  str TMP0, [BASE, RA, lsl #3]
    //|  ins_next
    dasm_put(Dst, 4286, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->asize), GG_G2DISP);
#line 3015 "vm_arm64.dasc"
    break;

  case BC_TSETV:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = src, RB = table, RC = key
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|   ldr TMP1, [BASE, RC, lsl #3]
    //|  checktab CARG2, ->vmeta_tsetv
    //|  checkint TMP1, >9		// Integer key?
    //|  ldr CARG3, TAB:CARG2->array
    //|   ldr CARG1w, TAB:CARG2->asize
    //|  add CARG3, CARG3, TMP1, uxtw #3
    //|   cmp TMP1w, CARG1w		// In array part?
    //|   bhs ->vmeta_tsetv
    //|  ldr TMP1, [CARG3]
    //|   ldr TMP0, [BASE, RA, lsl #3]
    //|    ldrb TMP2w, TAB:CARG2->marked
    //|  cmp TMP1, TISNIL			// Previous value is nil?
    //|  beq >5
    //|1:
    //|   str TMP0, [CARG3]
    //|    tbnz TMP2w, #2, >7		// isblack(table)
    //|2:
    //|   ins_next
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <1		// No metatable: done.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_newindex, <1	// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsetv
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP2w, TMP1
    dasm_put(Dst, 4311, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->asize), Dt6(->marked), GG_G2DISP, Dt6(->metatable), Dt6(->nomm), MM_newindex, Dt2(->gc.grayagain));
#line 3050 "vm_arm64.dasc"
    //|  b <2
    //|
    //|9:
    //|  asr ITYPE, TMP1, #47
    //|  cmn ITYPE, #-LJ_TSTR		// String key?
    //|  bne ->vmeta_tsetv
    //|   and STR:RC, TMP1, #LJ_GCVMASK
    //|  b ->BC_TSETS_Z
    dasm_put(Dst, 4368, ~LJ_GC_BLACK, Dt2(->gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TSTR, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32));
#line 3058 "vm_arm64.dasc"
    break;
  case BC_TSETS:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst, RB = table, RC = str_const (~)
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #3]
    //|  checktab CARG2, ->vmeta_tsets1
    //|->BC_TSETS_Z:
    //|  // TAB:CARG2 = GCtab *, STR:RC = GCstr *, RA = src
    //|  ldr TMP1w, TAB:CARG2->hmask
    //|   ldr TMP2w, STR:RC->hash
    //|    ldr NODE:CARG3, TAB:CARG2->node
    //|  and TMP1w, TMP1w, TMP2w		// idx = str->hash & tab->hmask
    //|  add TMP1, TMP1, TMP1, lsl #1
    //|  movn CARG4, #~LJ_TSTR
    //|    add NODE:CARG3, NODE:CARG3, TMP1, lsl #3  // node = tab->node + idx*3*8
    //|  add CARG4, STR:RC, CARG4, lsl #47	// Tagged key to look for.
    //|   strb wzr, TAB:CARG2->nomm	// Clear metamethod cache.
    //|1:
    //|  ldp TMP1, CARG1, NODE:CARG3->val
    //|   ldr NODE:TMP3, NODE:CARG3->next
    //|    ldrb TMP2w, TAB:CARG2->marked
    //|  cmp CARG1, CARG4
    //|  bne >5
    //|   ldr TMP0, [BASE, RA, lsl #3]
    //|  cmp TMP1, TISNIL			// Previous value is nil?
    //|  beq >4
    //|2:
    //|   str TMP0, NODE:CARG3->val
    //|    tbnz TMP2w, #2, >7		// isblack(table)
    //|3:
    //|  ins_next
    //|
    //|4:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <2		// No metatable: done.
    dasm_put(Dst, 4389, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->hmask), Dt5(->hash), Dt6(->node), ~LJ_TSTR, Dt6(->nomm), DtB(->val), DtB(->next), Dt6(->marked), DtB(->val), GG_G2DISP, Dt6(->metatable));
#line 3096 "vm_arm64.dasc"
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_newindex, <2	// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsets
    //|
    //|5:  // Follow hash chain.
    //|  mov NODE:CARG3, NODE:TMP3
    //|  cbnz NODE:TMP3, <1
    //|  // End of hash chain: key not found, add a new one.
    //|
    //|  // But check for __newindex first.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, >6		// No metatable: continue.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  // 'no __newindex' flag NOT set: check.
    //|  tbz TMP1w, #MM_newindex, ->vmeta_tsets
    //|6:
    //|  movn TMP1, #~LJ_TSTR
    //|   str PC, SAVE_PC
    //|  add TMP0, STR:RC, TMP1, lsl #47
    //|   str BASE, L->base
    //|   mov CARG1, L
    //|  str TMP0, TMPD
    //|   add CARG3, sp, TMPDofs
    //|  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
    //|  // Returns TValue *.
    //|  ldr BASE, L->base
    //|  ldr TMP0, [BASE, RA, lsl #3]
    //|  str TMP0, [CRET1]
    //|  b <3				// No 2nd write barrier needed.
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP2w, TMP1
    dasm_put(Dst, 4447, Dt6(->nomm), MM_newindex, Dt6(->metatable), Dt6(->nomm), MM_newindex, ~LJ_TSTR, Dt1(->base), Dt1(->base), Dt2(->gc.grayagain), ~LJ_GC_BLACK, Dt2(->gc.grayagain));
#line 3128 "vm_arm64.dasc"
    //|  b <3
    dasm_put(Dst, 4495, Dt6(->marked), Dt6(->gclist));
#line 3129 "vm_arm64.dasc"
    break;
  case BC_TSETB:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = src, RB = table, RC = index
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|  checktab CARG2, ->vmeta_tsetb
    //|  ldr CARG3, TAB:CARG2->array
    //|   ldr CARG1w, TAB:CARG2->asize
    //|  add CARG3, CARG3, RC, lsl #3
    //|   cmp RCw, CARG1w			// In array part?
    //|   bhs ->vmeta_tsetb
    //|  ldr TMP1, [CARG3]
    //|   ldr TMP0, [BASE, RA, lsl #3]
    //|    ldrb TMP2w, TAB:CARG2->marked
    //|  cmp TMP1, TISNIL			// Previous value is nil?
    //|  beq >5
    //|1:
    //|   str TMP0, [CARG3]
    //|    tbnz TMP2w, #2, >7		// isblack(table)
    //|2:
    //|   ins_next
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:CARG1, TAB:CARG2->metatable
    //|  cbz TAB:CARG1, <1		// No metatable: done.
    //|  ldrb TMP1w, TAB:CARG1->nomm
    //|  tbnz TMP1w, #MM_newindex, <1	// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsetb
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP2w, TMP1
    dasm_put(Dst, 4502, -LJ_TTAB, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->asize), Dt6(->marked), GG_G2DISP, Dt6(->metatable), Dt6(->nomm), MM_newindex, Dt2(->gc.grayagain), ~LJ_GC_BLACK);
#line 3161 "vm_arm64.dasc"
    //|  b <2
    dasm_put(Dst, 4557, Dt2(->gc.grayagain), Dt6(->marked), Dt6(->gclist));
#line 3162 "vm_arm64.dasc"
    break;
  case BC_TSETR:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = src, RB = table, RC = key
    //|  ldr CARG2, [BASE, RB, lsl #3]
    //|   ldr TMP1, [BASE, RC, lsl #3]
    //|  and TAB:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr CARG1, TAB:CARG2->array
    //|    ldrb TMP2w, TAB:CARG2->marked
    //|   ldr CARG4w, TAB:CARG2->asize
    //|  add CARG1, CARG1, TMP1, uxtw #3
    //|    tbnz TMP2w, #2, >7		// isblack(table)
    //|2:
    //|   cmp TMP1w, CARG4w		// In array part?
    //|   bhs ->vmeta_tsetr
    //|->BC_TSETR_Z:
    //|   ldr TMP0, [BASE, RA, lsl #3]
    //|   str TMP0, [CARG1]
    //|   ins_next
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP2w, TMP0
    //|  b <2
    dasm_put(Dst, 4566, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->array), Dt6(->marked), Dt6(->asize), GG_G2DISP, Dt2(->gc.grayagain), ~LJ_GC_BLACK, Dt2(->gc.grayagain), Dt6(->marked), Dt6(->gclist));
#line 3186 "vm_arm64.dasc"
    break;

  case BC_TSETM:
    //|  // RA = base (table at base-1), RC = num_const (start index)
    //|  add RA, BASE, RA, lsl #3
    //|1:
    //|   ldr RBw, SAVE_MULTRES
    //|  ldr TAB:CARG2, [RA, #-8]		// Guaranteed to be a table.
    //|   ldr TMP1, [KBASE, RC, lsl #3]	// Integer constant is in lo-word.
    //|    sub RB, RB, #8
    //|    cbz RB, >4			// Nothing to copy?
    //|  and TAB:CARG2, CARG2, #LJ_GCVMASK
    //|  ldr CARG1w, TAB:CARG2->asize
    //|   add CARG3w, TMP1w, RBw, lsr #3
    //|   ldr CARG4, TAB:CARG2->array
    //|  cmp CARG3, CARG1
    //|    add RB, RA, RB
    //|  bhi >5
    //|   add TMP1, CARG4, TMP1w, uxtw #3
    //|    ldrb TMP2w, TAB:CARG2->marked
    //|3:  // Copy result slots to table.
    //|   ldr TMP0, [RA], #8
    //|   str TMP0, [TMP1], #8
    //|  cmp RA, RB
    //|  blo <3
    //|    tbnz TMP2w, #2, >7		// isblack(table)
    //|4:
    //|  ins_next
    //|
    //|5:  // Need to resize array part.
    //|   str BASE, L->base
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  bl extern lj_tab_reasize		// (lua_State *L, GCtab *t, int nasize)
    //|  // Must not reallocate the stack.
    //|  b <1
    //|
    //|7:  // Possible table write barrier for any value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, TMP2w, TMP1
    //|  b <4
    dasm_put(Dst, 4609, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->asize), Dt6(->array), Dt6(->marked), GG_G2DISP, Dt1(->base), Dt2(->gc.grayagain), ~LJ_GC_BLACK, Dt2(->gc.grayagain), Dt6(->marked), Dt6(->gclist));
    dasm_put(Dst, 4668);
#line 3226 "vm_arm64.dasc"
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    //|  // RA = base, (RB = nresults+1,) RC = extra_nargs
    //|  ldr TMP0w, SAVE_MULTRES
    //|  decode_RC8RD NARGS8:RC, RC
    //|  add NARGS8:RC, NARGS8:RC, TMP0
    //|  b ->BC_CALL_Z
    dasm_put(Dst, 4671);
#line 3236 "vm_arm64.dasc"
    break;
  case BC_CALL:
    //|  decode_RC8RD NARGS8:RC, RC
    //|  // RA = base, (RB = nresults+1,) RC = (nargs+1)*8
    //|->BC_CALL_Z:
    //|  mov RB, BASE			// Save old BASE for vmeta_call.
    //|  add BASE, BASE, RA, lsl #3
    //|  ldr CARG3, [BASE]
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add BASE, BASE, #16
    //|  checkfunc CARG3, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4677, -LJ_TFUNC, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP);
#line 3248 "vm_arm64.dasc"
    break;

  case BC_CALLMT:
    //|  // RA = base, (RB = 0,) RC = extra_nargs
    //|  ldr TMP0w, SAVE_MULTRES
    //|  add NARGS8:RC, TMP0, RC, lsl #3
    //|  b ->BC_CALLT1_Z
    dasm_put(Dst, 4702);
#line 3255 "vm_arm64.dasc"
    break;
  case BC_CALLT:
    //|  lsl NARGS8:RC, RC, #3
    //|  // RA = base, (RB = 0,) RC = (nargs+1)*8
    //|->BC_CALLT1_Z:
    //|  add RA, BASE, RA, lsl #3
    //|  ldr TMP1, [RA]
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add RA, RA, #16
    //|  checktp CARG3, TMP1, LJ_TFUNC, ->vmeta_callt
    //|  ldr PC, [BASE, FRAME_PC]
    //|->BC_CALLT2_Z:
    //|   mov RB, #0
    //|   ldrb TMP2w, LFUNC:CARG3->ffid
    //|  tst PC, #FRAME_TYPE
    //|  bne >7
    //|1:
    //|  str TMP1, [BASE, FRAME_FUNC]	// Copy function down, but keep PC.
    //|  cbz NARGS8:RC, >3
    //|2:
    //|  ldr TMP0, [RA, RB]
    //|   add TMP1, RB, #8
    //|   cmp TMP1, NARGS8:RC
    //|  str TMP0, [BASE, RB]
    //|    mov RB, TMP1
    //|   bne <2
    //|3:
    //|  cmp TMP2, #1			// (> FF_C) Calling a fast function?
    //|  bhi >5
    //|4:
    //|  ins_callt
    //|
    //|5:  // Tailcall to a fast function with a Lua frame below.
    //|  ldrb RAw, [PC, #-4+OFS_RA]
    //|  sub CARG1, BASE, RA, lsl #3
    //|  ldr LFUNC:CARG1, [CARG1, #-32]
    //|  and LFUNC:CARG1, CARG1, #LJ_GCVMASK
    //|  ldr CARG1, LFUNC:CARG1->pc
    //|  ldr KBASE, [CARG1, #PC2PROTO(k)]
    //|  b <4
    //|
    //|7:  // Tailcall from a vararg function.
    //|  eor PC, PC, #FRAME_VARG
    dasm_put(Dst, 4707, -LJ_TFUNC, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->ffid), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), Dt7(->pc), GG_G2DISP, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), PC2PROTO(k));
#line 3298 "vm_arm64.dasc"
    //|  tst PC, #FRAME_TYPEP		// Vararg frame below?
    //|  csel TMP2, RB, TMP2, ne		// Clear ffid if no Lua function below.
    //|  bne <1
    //|  sub BASE, BASE, PC
    //|  ldr PC, [BASE, FRAME_PC]
    //|  tst PC, #FRAME_TYPE
    //|  csel TMP2, RB, TMP2, ne		// Clear ffid if no Lua function below.
    //|  b <1
    dasm_put(Dst, 4769, (unsigned int)(FRAME_VARG), (unsigned int)((unsigned long long)(FRAME_VARG)>>32), (unsigned int)(FRAME_TYPEP), (unsigned int)((unsigned long long)(FRAME_TYPEP)>>32), (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32));
#line 3306 "vm_arm64.dasc"
    break;

  case BC_ITERC:
    //|  // RA = base, (RB = nresults+1, RC = nargs+1 (2+1))
    //|  add RA, BASE, RA, lsl #3
    //|  ldr CARG3, [RA, #-24]
    //|    mov RB, BASE			// Save old BASE for vmeta_call.
    //|   ldp CARG1, CARG2, [RA, #-16]
    //|    add BASE, RA, #16
    //|    mov NARGS8:RC, #16		// Iterators get 2 arguments.
    //|  str CARG3, [RA]			// Copy callable.
    //|   stp CARG1, CARG2, [RA, #16]	// Copy state and control var.
    //|  checkfunc CARG3, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4784, -LJ_TFUNC, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), GG_G2DISP);
#line 3320 "vm_arm64.dasc"
    break;

  case BC_ITERN:
    //|  // RA = base, (RB = nresults+1, RC = nargs+1 (2+1))
    //|.if JIT
    //|  // NYI: add hotloop, record BC_ITERN.
    //|.endif
    //|  add RA, BASE, RA, lsl #3
    //|  ldr TAB:RB, [RA, #-16]
    //|    ldrh TMP3w, [PC, # OFS_RD]
    //|  ldr CARG1w, [RA, #-8+LO]		// Get index from control var.
    //|    add PC, PC, #4
    //|    add TMP3, PC, TMP3, lsl #2
    //|  and TAB:RB, RB, #LJ_GCVMASK
    //|    sub TMP3, TMP3, #0x20000
    //|  ldr TMP1w, TAB:RB->asize
    //|   ldr CARG2, TAB:RB->array
    //|1:  // Traverse array part.
    //|  subs RC, CARG1, TMP1
    //|   add CARG3, CARG2, CARG1, lsl #3
    //|  bhs >5				// Index points after array part?
    //|   ldr TMP0, [CARG3]
    //|   cmp TMP0, TISNIL
    //|   cinc CARG1, CARG1, eq		// Skip holes in array part.
    //|   beq <1
    //|   add CARG1, CARG1, TISNUM
    //|   stp CARG1, TMP0, [RA]
    //|    add CARG1, CARG1, #1
    //|3:
    //|    str CARG1w, [RA, #-8+LO]	// Update control var.
    //|  mov PC, TMP3
    //|4:
    //|  ins_next
    //|
    //|5:  // Traverse hash part.
    //|  ldr TMP2w, TAB:RB->hmask
    //|   ldr NODE:RB, TAB:RB->node
    //|6:
    //|   add CARG1, RC, RC, lsl #1
    //|  cmp RC, TMP2			// End of iteration? Branch to ITERN+1.
    //|   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
    //|  bhi <4
    //|  ldp TMP0, CARG1, NODE:CARG3->val
    //|  cmp TMP0, TISNIL
    //|   add RC, RC, #1
    //|  beq <6				// Skip holes in hash part.
    //|  stp CARG1, TMP0, [RA]
    //|  add CARG1, RC, TMP1
    //|  b <3
    dasm_put(Dst, 4810, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt6(->asize), Dt6(->array), GG_G2DISP, Dt6(->hmask), Dt6(->node), DtB(->val));
#line 3369 "vm_arm64.dasc"
    break;

  case BC_ISNEXT:
    //|  // RA = base, RC = target (points to ITERN)
    //|  add RA, BASE, RA, lsl #3
    //|  ldr CFUNC:CARG1, [RA, #-24]
    //|     add RC, PC, RC, lsl #2
    //|   ldp TAB:CARG3, CARG4, [RA, #-16]
    //|     sub RC, RC, #0x20000
    //|  checkfunc CFUNC:CARG1, >5
    //|   asr TMP0, TAB:CARG3, #47
    //|  ldrb TMP1w, CFUNC:CARG1->ffid
    //|   cmn TMP0, #-LJ_TTAB
    //|   ccmp CARG4, TISNIL, #0, eq
    //|  ccmp TMP1w, #FF_next_N, #0, eq
    //|  bne >5
    //|  mov TMP0w, #0xfffe7fff
    //|  lsl TMP0, TMP0, #32
    //|  str TMP0, [RA, #-8]		// Initialize control var.
    //|1:
    //|     mov PC, RC
    //|  ins_next
    //|
    //|5:  // Despecialize bytecode if any of the checks fail.
    //|  mov TMP0, #BC_JMP
    //|   mov TMP1, #BC_ITERC
    //|  strb TMP0w, [PC, #-4+OFS_OP]
    //|   strb TMP1w, [RC, # OFS_OP]
    //|  b <1
    dasm_put(Dst, 4869, -LJ_TFUNC, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt8(->ffid), -LJ_TTAB, FF_next_N, GG_G2DISP, BC_JMP, BC_ITERC);
#line 3398 "vm_arm64.dasc"
    break;

  case BC_VARG:
    //|  decode_RB RB, INS
    //|   and RC, RC, #255
    //|  // RA = base, RB = (nresults+1), RC = numparams
    //|  ldr TMP1, [BASE, FRAME_PC]
    //|  add RC, BASE, RC, lsl #3
    //|   add RA, BASE, RA, lsl #3
    //|  add RC, RC, #FRAME_VARG
    //|   add TMP2, RA, RB, lsl #3
    //|  sub RC, RC, TMP1			// RC = vbase
    //|  // Note: RC may now be even _above_ BASE if nargs was < numparams.
    //|   sub TMP3, BASE, #16		// TMP3 = vtop
    //|  cbz RB, >5
    //|   sub TMP2, TMP2, #16
    //|1:  // Copy vararg slots to destination slots.
    //|  cmp RC, TMP3
    //|  ldr TMP0, [RC], #8
    //|  csel TMP0, TMP0, TISNIL, lo
    //|   cmp RA, TMP2
    //|  str TMP0, [RA], #8
    //|   blo <1
    //|2:
    //|  ins_next
    //|
    //|5:  // Copy all varargs.
    //|  ldr TMP0, L->maxstack
    //|   subs TMP2, TMP3, RC
    //|   csel RB, xzr, TMP2, le		// MULTRES = (max(vtop-vbase,0)+1)*8
    //|   add RB, RB, #8
    //|  add TMP1, RA, TMP2
    //|   str RBw, SAVE_MULTRES
    //|   ble <2				// Nothing to copy.
    //|  cmp TMP1, TMP0
    //|  bhi >7
    //|6:
    //|  ldr TMP0, [RC], #8
    //|  str TMP0, [RA], #8
    //|  cmp RC, TMP3
    //|  blo <6
    //|  b <2
    //|
    //|7:  // Grow stack for varargs.
    //|  lsr CARG2, TMP2, #3
    //|   stp BASE, RA, L->base
    //|  mov CARG1, L
    //|  sub RC, RC, BASE			// Need delta, because BASE may change.
    //|   str PC, SAVE_PC
    //|  bl extern lj_state_growstack	// (lua_State *L, int n)
    //|  ldp BASE, RA, L->base
    //|  add RC, BASE, RC
    //|  sub TMP3, BASE, #16
    //|  b <6
    dasm_put(Dst, 4913, FRAME_VARG, GG_G2DISP, Dt1(->maxstack), Dt1(->base), Dt1(->base));
#line 3452 "vm_arm64.dasc"
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    //|  // RA = results, RC = extra results
    //|  ldr TMP0w, SAVE_MULTRES
    //|   ldr PC, [BASE, FRAME_PC]
    //|    add RA, BASE, RA, lsl #3
    //|  add RC, TMP0, RC, lsl #3
    //|  b ->BC_RETM_Z
    dasm_put(Dst, 4979);
#line 3463 "vm_arm64.dasc"
    break;

  case BC_RET:
    //|  // RA = results, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|    add RA, BASE, RA, lsl #3
    //|->BC_RETM_Z:
    //|   str RCw, SAVE_MULTRES
    //|1:
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|  bne ->BC_RETV2_Z
    //|
    //|->BC_RET_Z:
    //|  // BASE = base, RA = resultptr, RC = (nresults+1)*8, PC = return
    //|  ldr INSw, [PC, #-4]
    //|  subs TMP1, RC, #8
    //|   sub CARG3, BASE, #16
    //|  beq >3
    //|2:
    //|  ldr TMP0, [RA], #8
    //|   add BASE, BASE, #8
    //|   sub TMP1, TMP1, #8
    //|  str TMP0, [BASE, #-24]
    //|   cbnz TMP1, <2
    //|3:
    //|  decode_RA RA, INS
    //|  sub CARG4, CARG3, RA, lsl #3
    //|   decode_RB RB, INS
    //|  ldr LFUNC:CARG1, [CARG4, FRAME_FUNC]
    //|5:
    //|  cmp RC, RB, lsl #3		// More results expected?
    //|  blo >6
    //|  and LFUNC:CARG1, CARG1, #LJ_GCVMASK
    //|  mov BASE, CARG4
    //|  ldr CARG2, LFUNC:CARG1->pc
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|   ins_next
    //|
    //|6:  // Fill up results with nil.
    //|  add BASE, BASE, #8
    //|   add RC, RC, #8
    //|  str TISNIL, [BASE, #-24]
    //|  b <5
    //|
    //|->BC_RETV1_Z:  // Non-standard return case.
    //|  add RA, BASE, RA, lsl #3
    //|->BC_RETV2_Z:
    //|  tst CARG2, #FRAME_TYPEP
    //|  bne ->vm_return
    //|  // Return from vararg function: relocate BASE down.
    //|  sub BASE, BASE, CARG2
    dasm_put(Dst, 4986, (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), (unsigned int)(FRAME_VARG), (unsigned int)((unsigned long long)(FRAME_VARG)>>32), (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), PC2PROTO(k), GG_G2DISP, (unsigned int)(FRAME_TYPEP), (unsigned int)((unsigned long long)(FRAME_TYPEP)>>32));
#line 3516 "vm_arm64.dasc"
    //|  ldr PC, [BASE, FRAME_PC]
    //|  b <1
    dasm_put(Dst, 5048);
#line 3518 "vm_arm64.dasc"
    break;

  case BC_RET0: case BC_RET1:
    //|  // RA = results, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|   str RCw, SAVE_MULTRES
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|  bne ->BC_RETV1_Z
    //|   ldr INSw, [PC, #-4]
    dasm_put(Dst, 5053, (unsigned int)(FRAME_TYPE), (unsigned int)((unsigned long long)(FRAME_TYPE)>>32), (unsigned int)(FRAME_VARG), (unsigned int)((unsigned long long)(FRAME_VARG)>>32));
#line 3529 "vm_arm64.dasc"
    if (op == BC_RET1) {
      //|  ldr TMP0, [BASE, RA, lsl #3]
      dasm_put(Dst, 5064);
#line 3531 "vm_arm64.dasc"
    }
    //|  sub CARG4, BASE, #16
    //|   decode_RA RA, INS
    //|  sub BASE, CARG4, RA, lsl #3
    dasm_put(Dst, 5066);
#line 3535 "vm_arm64.dasc"
    if (op == BC_RET1) {
      //|  str TMP0, [CARG4], #8
      dasm_put(Dst, 5070);
#line 3537 "vm_arm64.dasc"
    }
    //|   decode_RB RB, INS
    //|  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    //|5:
    //|  cmp RC, RB, lsl #3
    //|  blo >6
    //|  and LFUNC:CARG1, CARG1, #LJ_GCVMASK
    //|  ldr CARG2, LFUNC:CARG1->pc
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|  ins_next
    //|
    //|6:  // Fill up results with nil.
    //|  add RC, RC, #8
    //|  str TISNIL, [CARG4], #8
    //|  b <5
    dasm_put(Dst, 5072, (unsigned int)(LJ_GCVMASK), (unsigned int)((unsigned long long)(LJ_GCVMASK)>>32), Dt7(->pc), PC2PROTO(k), GG_G2DISP);
#line 3552 "vm_arm64.dasc"
    break;

  /* -- Loops and branches ------------------------------------------------ */

  //|.define FOR_IDX,  [RA];      .define FOR_TIDX,  [RA, #4]
  //|.define FOR_STOP, [RA, #8];  .define FOR_TSTOP, [RA, #12]
  //|.define FOR_STEP, [RA, #16]; .define FOR_TSTEP, [RA, #20]
  //|.define FOR_EXT,  [RA, #24]; .define FOR_TEXT,  [RA, #28]

  case BC_FORL:
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_IFORL follows.
    dasm_put(Dst, 5097, GG_G2DISP+GG_DISP2HOT, HOTCOUNT_LOOP);
#line 3566 "vm_arm64.dasc"
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    //|  // RA = base, RC = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    //|  add RA, BASE, RA, lsl #3
    //|  ldp CARG1, CARG2, FOR_IDX		// CARG1 = IDX, CARG2 = STOP
    //|   ldr CARG3, FOR_STEP			// CARG3 = STEP
    dasm_put(Dst, 5108);
#line 3580 "vm_arm64.dasc"
    if (op != BC_JFORL) {
      //|   add RC, PC, RC, lsl #2
      //|   sub RC, RC, #0x20000
      dasm_put(Dst, 5112);
#line 3583 "vm_arm64.dasc"
    }
    //|  checkint CARG1, >5
    dasm_put(Dst, 5115);
#line 3585 "vm_arm64.dasc"
    if (!vk) {
      //|  checkint CARG2, ->vmeta_for
      //|   checkint CARG3, ->vmeta_for
      //|  tbnz CARG3w, #31, >4
      //|  cmp CARG1w, CARG2w
      dasm_put(Dst, 5119);
#line 3590 "vm_arm64.dasc"
    } else {
      //|  adds CARG1w, CARG1w, CARG3w
      //|  bvs >2
      //|   add TMP0, CARG1, TISNUM
      //|  tbnz CARG3w, #31, >4
      //|  cmp CARG1w, CARG2w
      dasm_put(Dst, 5129);
#line 3596 "vm_arm64.dasc"
    }
    //|1:
    dasm_put(Dst, 5137);
#line 3598 "vm_arm64.dasc"
    if (op == BC_FORI) {
      //|  csel PC, RC, PC, gt
      dasm_put(Dst, 5139);
#line 3600 "vm_arm64.dasc"
    } else if (op == BC_JFORI) {
      //|  mov PC, RC
      //|  ldrh RCw, [RC, #-4+OFS_RD]
      dasm_put(Dst, 5141);
#line 3603 "vm_arm64.dasc"
    } else if (op == BC_IFORL) {
      //|  csel PC, RC, PC, le
      dasm_put(Dst, 5144);
#line 3605 "vm_arm64.dasc"
    }
    if (vk) {
      //|   str TMP0, FOR_IDX
      //|   str TMP0, FOR_EXT
      dasm_put(Dst, 5146);
#line 3609 "vm_arm64.dasc"
    } else {
      //|  str CARG1, FOR_EXT
      dasm_put(Dst, 5149);
#line 3611 "vm_arm64.dasc"
    }
    if (op == BC_JFORI || op == BC_JFORL) {
      //|  ble =>BC_JLOOP
      dasm_put(Dst, 5151, BC_JLOOP);
#line 3614 "vm_arm64.dasc"
    }
    //|2:
    //|   ins_next
    //|
    //|4:  // Invert check for negative step.
    //|  cmp CARG2w, CARG1w
    //|  b <1
    //|
    //|5:  // FP loop.
    //|  ldp d0, d1, FOR_IDX
    //|  blo ->vmeta_for
    dasm_put(Dst, 5154, GG_G2DISP);
#line 3625 "vm_arm64.dasc"
    if (!vk) {
      //|  checknum CARG2, ->vmeta_for
      //|   checknum CARG3, ->vmeta_for
      //|  str d0, FOR_EXT
      dasm_put(Dst, 5171);
#line 3629 "vm_arm64.dasc"
    } else {
      //|  ldr d2, FOR_STEP
      //|  fadd d0, d0, d2
      dasm_put(Dst, 5179);
#line 3632 "vm_arm64.dasc"
    }
    //|  tbnz CARG3, #63, >7
    //|  fcmp d0, d1
    //|6:
    dasm_put(Dst, 5182);
#line 3636 "vm_arm64.dasc"
    if (vk) {
      //|  str d0, FOR_IDX
      //|  str d0, FOR_EXT
      dasm_put(Dst, 5187);
#line 3639 "vm_arm64.dasc"
    }
    if (op == BC_FORI) {
      //|  csel PC, RC, PC, hi
      dasm_put(Dst, 5190);
#line 3642 "vm_arm64.dasc"
    } else if (op == BC_JFORI) {
      //|  ldrh RCw, [RC, #-4+OFS_RD]
      //|  bls =>BC_JLOOP
      dasm_put(Dst, 5192, BC_JLOOP);
#line 3645 "vm_arm64.dasc"
    } else if (op == BC_IFORL) {
      //|  csel PC, RC, PC, ls
      dasm_put(Dst, 5196);
#line 3647 "vm_arm64.dasc"
    } else {
      //|  bls =>BC_JLOOP
      dasm_put(Dst, 5198, BC_JLOOP);
#line 3649 "vm_arm64.dasc"
    }
    //|  b <2
    //|
    //|7:  // Invert check for negative step.
    //|  fcmp d1, d0
    //|  b <6
    dasm_put(Dst, 5201);
#line 3655 "vm_arm64.dasc"
    break;

  case BC_ITERL:
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_IITERL follows.
    dasm_put(Dst, 5208, GG_G2DISP+GG_DISP2HOT, HOTCOUNT_LOOP);
#line 3662 "vm_arm64.dasc"
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    //|  // RA = base, RC = target
    //|  ldr CARG1, [BASE, RA, lsl #3]
    //|   add TMP1, BASE, RA, lsl #3
    //|  cmp CARG1, TISNIL
    //|  beq >1				// Stop if iterator returned nil.
    dasm_put(Dst, 5219);
#line 3674 "vm_arm64.dasc"
    if (op == BC_JITERL) {
      //|  str CARG1, [TMP1, #-8]
      //|  b =>BC_JLOOP
      dasm_put(Dst, 5225, BC_JLOOP);
#line 3677 "vm_arm64.dasc"
    } else {
      //|  add TMP0, PC, RC, lsl #2	// Otherwise save control var + branch.
      //|  sub PC, TMP0, #0x20000
      //|  str CARG1, [TMP1, #-8]
      dasm_put(Dst, 5229);
#line 3681 "vm_arm64.dasc"
    }
    //|1:
    //|  ins_next
    dasm_put(Dst, 5233, GG_G2DISP);
#line 3684 "vm_arm64.dasc"
    break;

  case BC_LOOP:
    //|  // RA = base, RC = target (loop extent)
    //|  // Note: RA/RC is only used by trace recorder to determine scope/extent
    //|  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_ILOOP follows.
    dasm_put(Dst, 5242, GG_G2DISP+GG_DISP2HOT, HOTCOUNT_LOOP);
#line 3694 "vm_arm64.dasc"
    break;

  case BC_ILOOP:
    //|  // RA = base, RC = target (loop extent)
    //|  ins_next
    dasm_put(Dst, 5253, GG_G2DISP);
#line 3699 "vm_arm64.dasc"
    break;

  case BC_JLOOP:
    //|.if JIT
    //|  // RA = base (ignored), RC = traceno
    //|  ldr CARG1, [GL, #GL_J(trace)]
    //|   mov CARG2w, #0  // Traces on ARM64 don't store the trace #, so use 0.
    //|  ldr TRACE:RC, [CARG1, RC, lsl #3]
    //|   st_vmstate CARG2w
    //|  ldr RA, TRACE:RC->mcode
    //|   str BASE, GL->jit_base
    //|   str L, GL->tmpbuf.L
    //|  sub sp, sp, #16	// See SPS_FIXED. Avoids sp adjust in every root trace.
    //|  br RA
    //|.endif
    dasm_put(Dst, 5261, GL_J(trace), Dt2(->vmstate), DtD(->mcode), Dt2(->jit_base), Dt2(->tmpbuf.L));
#line 3714 "vm_arm64.dasc"
    break;

  case BC_JMP:
    //|  // RA = base (only used by trace recorder), RC = target
    //|  add RC, PC, RC, lsl #2
    //|  sub PC, RC, #0x20000
    //|  ins_next
    dasm_put(Dst, 5276, GG_G2DISP);
#line 3721 "vm_arm64.dasc"
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
    //|.if JIT
    //|  hotcall
    //|.endif
    dasm_put(Dst, 5286, GG_G2DISP+GG_DISP2HOT, HOTCOUNT_CALL);
#line 3729 "vm_arm64.dasc"
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    //|  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   ldrb TMP1w, [PC, #-4+PC2PROTO(numparams)]
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|  bhi ->vm_growstack_l
    //|2:
    //|  cmp NARGS8:RC, TMP1, lsl #3	// Check for missing parameters.
    //|  blo >3
    dasm_put(Dst, 5297, Dt1(->maxstack), -4+PC2PROTO(numparams), -4+PC2PROTO(k));
#line 3747 "vm_arm64.dasc"
    if (op == BC_JFUNCF) {
      //|  decode_RD RC, INS
      //|  b =>BC_JLOOP
      dasm_put(Dst, 5311, BC_JLOOP);
#line 3750 "vm_arm64.dasc"
    } else {
      //|  ins_next
      dasm_put(Dst, 5315, GG_G2DISP);
#line 3752 "vm_arm64.dasc"
    }
    //|
    //|3:  // Clear missing parameters.
    //|  str TISNIL, [BASE, NARGS8:RC]
    //|  add NARGS8:RC, NARGS8:RC, #8
    //|  b <2
    dasm_put(Dst, 5323);
#line 3758 "vm_arm64.dasc"
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    //|  NYI  // NYI: compiled vararg functions
    dasm_put(Dst, 5329);
#line 3765 "vm_arm64.dasc"
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   movn TMP0, #~LJ_TFUNC
    //|   add TMP2, BASE, RC
    //|   add LFUNC:CARG3, CARG3, TMP0, lsl #47
    //|  add RA, RA, RC
    //|   add TMP0, RC, #16+FRAME_VARG
    //|   str LFUNC:CARG3, [TMP2], #8	// Store (tagged) copy of LFUNC.
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|   str TMP0, [TMP2], #8		// Store delta + FRAME_VARG.
    //|  bhs ->vm_growstack_l
    //|   sub RC, TMP2, #16
    //|  ldrb TMP1w, [PC, #-4+PC2PROTO(numparams)]
    //|   mov RA, BASE
    //|   mov BASE, TMP2
    //|  cbz TMP1, >2
    //|1:
    //|  cmp RA, RC			// Less args than parameters?
    //|  bhs >3
    //|   ldr TMP0, [RA]
    //|  sub TMP1, TMP1, #1
    //|    str TISNIL, [RA], #8		// Clear old fixarg slot (help the GC).
    //|   str TMP0, [TMP2], #8
    //|  cbnz TMP1, <1
    //|2:
    //|  ins_next
    //|
    //|3:
    //|  sub TMP1, TMP1, #1
    //|   str TISNIL, [TMP2], #8
    //|  cbz TMP1, <2
    //|  b <3
    dasm_put(Dst, 5331, Dt1(->maxstack), ~LJ_TFUNC, 16+FRAME_VARG, -4+PC2PROTO(k), -4+PC2PROTO(numparams), GG_G2DISP);
#line 3801 "vm_arm64.dasc"
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      //|  ldr CARG4, CFUNC:CARG3->f
      dasm_put(Dst, 5380, Dt8(->f));
#line 3808 "vm_arm64.dasc"
    } else {
      //|  ldr CARG4, GL->wrapf
      dasm_put(Dst, 5383, Dt2(->wrapf));
#line 3810 "vm_arm64.dasc"
    }
    //|   add CARG2, RA, NARGS8:RC
    //|   ldr CARG1, L->maxstack
    //|  add RC, BASE, NARGS8:RC
    //|   cmp CARG2, CARG1
    //|  stp BASE, RC, L->base
    dasm_put(Dst, 5386, Dt1(->maxstack), Dt1(->base));
#line 3816 "vm_arm64.dasc"
    if (op == BC_FUNCCW) {
      //|  ldr CARG2, CFUNC:CARG3->f
      dasm_put(Dst, 5394, Dt8(->f));
#line 3818 "vm_arm64.dasc"
    }
    //|    mv_vmstate TMP0w, C
    //|  mov CARG1, L
    //|   bhi ->vm_growstack_c		// Need to grow stack.
    //|    st_vmstate TMP0w
    //|  blr CARG4			// (lua_State *L [, lua_CFunction f])
    //|  // Returns nresults.
    //|  ldp BASE, TMP1, L->base
    //|    str L, GL->cur_L
    //|   sbfiz RC, CRET1, #3, #32
    //|    st_vmstate ST_INTERP
    //|  ldr PC, [BASE, FRAME_PC]
    //|   sub RA, TMP1, RC		// RA = L->top - nresults*8
    //|  b ->vm_returnc
    dasm_put(Dst, 5397, LJ_VMST_C, Dt2(->vmstate), Dt1(->base), Dt2(->cur_L), Dt2(->vmstate));
#line 3832 "vm_arm64.dasc"
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  //|.code_op
  dasm_put(Dst, 5417);
#line 3852 "vm_arm64.dasc"
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
  int i, cf = CFRAME_SIZE >> 3;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",%%progbits\n");
    fprintf(ctx->fp,
	".Lframe0:\n"
	"\t.long .LECIE0-.LSCIE0\n"
	".LSCIE0:\n"
	"\t.long 0xffffffff\n"
	"\t.byte 0x1\n"
	"\t.string \"\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -8\n"
	"\t.byte 30\n"				/* Return address is in lr. */
	"\t.byte 0xc\n\t.uleb128 31\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 3\n"
	".LECIE0:\n\n");
    fprintf(ctx->fp,
	".LSFDE0:\n"
	"\t.long .LEFDE0-.LASFDE0\n"
	".LASFDE0:\n"
	"\t.long .Lframe0\n"
	"\t.quad .Lbegin\n"
	"\t.quad %d\n"
	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
	"\t.byte 0x9d\n\t.uleb128 %d\n"		/* offset fp */
	"\t.byte 0x9e\n\t.uleb128 %d\n",	/* offset lr */
	fcofs, CFRAME_SIZE, cf, cf-1);
    for (i = 19; i <= 28; i++)  /* offset x19-x28 */
      fprintf(ctx->fp, "\t.byte 0x%x\n\t.uleb128 %d\n", 0x80+i, cf-i+17);
    for (i = 8; i <= 15; i++)  /* offset d8-d15 */
      fprintf(ctx->fp, "\t.byte 5\n\t.uleb128 0x%x\n\t.uleb128 %d\n",
	      64+i, cf-i-4);
    fprintf(ctx->fp,
	"\t.align 3\n"
	".LEFDE0:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".LSFDE1:\n"
	"\t.long .LEFDE1-.LASFDE1\n"
	".LASFDE1:\n"
	"\t.long .Lframe0\n"
	"\t.quad lj_vm_ffi_call\n"
	"\t.quad %d\n"
	"\t.byte 0xe\n\t.uleb128 32\n"		/* def_cfa_offset */
	"\t.byte 0x9d\n\t.uleb128 4\n"		/* offset fp */
	"\t.byte 0x9e\n\t.uleb128 3\n"		/* offset lr */
	"\t.byte 0x93\n\t.uleb128 2\n"		/* offset x19 */
	"\t.align 3\n"
	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
    fprintf(ctx->fp, "\t.section .eh_frame,\"a\",%%progbits\n");
    fprintf(ctx->fp,
	".Lframe1:\n"
	"\t.long .LECIE1-.LSCIE1\n"
	".LSCIE1:\n"
	"\t.long 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zPR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -8\n"
	"\t.byte 30\n"				/* Return address is in lr. */
	"\t.uleb128 6\n"			/* augmentation length */
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.long lj_err_unwind_dwarf-.\n"
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.byte 0xc\n\t.uleb128 31\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 3\n"
	".LECIE1:\n\n");
    fprintf(ctx->fp,
	".LSFDE2:\n"
	"\t.long .LEFDE2-.LASFDE2\n"
	".LASFDE2:\n"
	"\t.long .LASFDE2-.Lframe1\n"
	"\t.long .Lbegin-.\n"
	"\t.long %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
	"\t.byte 0x9d\n\t.uleb128 %d\n"		/* offset fp */
	"\t.byte 0x9e\n\t.uleb128 %d\n",	/* offset lr */
	fcofs, CFRAME_SIZE, cf, cf-1);
    for (i = 19; i <= 28; i++)  /* offset x19-x28 */
      fprintf(ctx->fp, "\t.byte 0x%x\n\t.uleb128 %d\n", 0x80+i, cf-i+17);
    for (i = 8; i <= 15; i++)  /* offset d8-d15 */
      fprintf(ctx->fp, "\t.byte 5\n\t.uleb128 0x%x\n\t.uleb128 %d\n",
	      64+i, cf-i-4);
    fprintf(ctx->fp,
	"\t.align 3\n"
	".LEFDE2:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".Lframe2:\n"
	"\t.long .LECIE2-.LSCIE2\n"
	".LSCIE2:\n"
	"\t.long 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -8\n"
	"\t.byte 30\n"				/* Return address is in lr. */
	"\t.uleb128 1\n"			/* augmentation length */
	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
	"\t.byte 0xc\n\t.uleb128 31\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 3\n"
	".LECIE2:\n\n");
    fprintf(ctx->fp,
	".LSFDE3:\n"
	"\t.long .LEFDE3-.LASFDE3\n"
	".LASFDE3:\n"
	"\t.long .LASFDE3-.Lframe2\n"
	"\t.long lj_vm_ffi_call-.\n"
	"\t.long %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0xe\n\t.uleb128 32\n"		/* def_cfa_offset */
	"\t.byte 0x9d\n\t.uleb128 4\n"		/* offset fp */
	"\t.byte 0x9e\n\t.uleb128 3\n"		/* offset lr */
	"\t.byte 0x93\n\t.uleb128 2\n"		/* offset x19 */
	"\t.align 3\n"
	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
    break;
  default:
    break;
  }
}

